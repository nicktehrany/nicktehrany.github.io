<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nick Tehrany</title>
    <link>https://nicktehrany.github.io/</link>
    <description>Recent content on Nick Tehrany</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 08 Feb 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://nicktehrany.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction</title>
      <link>https://nicktehrany.github.io/in4391-distributed-systems-notes/introduction/</link>
      <pubDate>Mon, 08 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4391-distributed-systems-notes/introduction/</guid>
      <description>What is the difference between parallel computing and distributed computing?
In parallel computing there typically is one job that is split into multiple tasks, which are then split up to different cores/threads that run simultaneously. Such systems typically are homogenous, the hardware is all the same, i.e. the threads run in the same system on the same CPU.
In distributed computing there are also multiple tasks, but these can come from one job or possibly multiple jobs.</description>
    </item>
    
    <item>
      <title>IN4391 Distributed Systems</title>
      <link>https://nicktehrany.github.io/in4391-distributed-systems-notes/</link>
      <pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4391-distributed-systems-notes/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Info</title>
      <link>https://nicktehrany.github.io/in4391-distributed-systems-notes/info/</link>
      <pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4391-distributed-systems-notes/info/</guid>
      <description>IN4391 Distributed Systems notes at TUDelft (Q3).
Studyguide: https://studiegids.tudelft.nl/a101_displayCourse.do?course_id=55274 Book: Andrew S. Tanenbaum, Maarten Van Steen, Distributed Systems, Principles and Paradigms (2nd Edition), Prentice Hall, 2006.
All content and images are based on and retrieved from the book in addition to the content of the lectures.</description>
    </item>
    
    <item>
      <title>State Machine Replication</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/smr/</link>
      <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/smr/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Stabilization</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/stabilization/</link>
      <pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/stabilization/</guid>
      <description>For dealing with transient faults, which means that components in a distributed system may only fail temporarily, stabilizing algorithms have been devised that bring a system back into a correct sate from any incorrect sate it may be in.
A predicate, which is the defined order of saying what functions correctly and incorrectly and is defined as legal and illegal configurations, is called stable if once it holds and no faults occur, it continues to hold.</description>
    </item>
    
    <item>
      <title>Consensus</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/consensus/</link>
      <pubDate>Sat, 23 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/consensus/</guid>
      <description>Distributed systems will have to deal with faults caused by software or hardware components, not operating according to specification. Faults can be classified as permanent, once a processor exhibits a fault it will be considered as faulty for ever, which also leads to crash failures and malicious or Byzantine failures. Transient faults are when a processor may exhibit a fault but will return to correct operation again, i.e. transmission error or short power loss.</description>
    </item>
    
    <item>
      <title>Minimum-Weight Spanning Trees</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/mst/</link>
      <pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/mst/</guid>
      <description>A reason for using minimum-weight spanning trees (MST) is to broadcast some message along the tree with minimum weight, if for example the transmission cost is used as the weight for edges. MSTs are constructed from weighted (unique weights) undirected graphs. Unique weights are required for finding a unique solution for an MST, and for the following algorithm. a fragment of graph $G$ is a subtree of its MST. Edge $e$ of $G$ is the minimum-weight outgoing edge (MOE) of fragment $F$ if it has the minimum weight that connects $F$ to another fragment.</description>
    </item>
    
    <item>
      <title>Traversal Algorithms</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/traversal/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/traversal/</guid>
      <description>Information in a DS may need to be propagated from a single node to all other nodes and the originator may want to receive information back. In a spanning tree of an undirected network, which is a sub-network of the original network that contains all nodes of the original network and that has the structure of a tree (the sparsest type of sub-network that keeps the system connected), messages need to traverse the tree efficiently.</description>
    </item>
    
    <item>
      <title>Election</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/election/</link>
      <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/election/</guid>
      <description>It may sometimes be necessary in a DS to assign a certain process with a higher privilege, for which election is used. If each process has a unique integer id, the system isa said to be non-anonymous and anonymous otherwise. In anonymous rings no deterministic solution exists to election, as processes need to randomly generate some id value (e.g. 64 bit number). Algorithms that work in a ring of an unknown size are called uniform.</description>
    </item>
    
    <item>
      <title>Token Loss</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/tokenloss/</link>
      <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/tokenloss/</guid>
      <description>Since token based systems require the presence of a single token, if a token is lost due to unreliable links, this has to be detected and a single new token has to be generated n a unidirectional ring.
It works by using two tokens $t_0$ and $t_1$ that detect the loss of each other. The token message that transfers the token contains a token number that is the index of the token and a counter which is equal to plus or minus the number of times the tokens have met, plus if the token id is 0 and minus if it is 1.</description>
    </item>
    
    <item>
      <title>Mutual Exclusion</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/mutualexclusion/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/mutualexclusion/</guid>
      <description>In a distributed system in order to access the resource, a process will execute the critical section of the resource, hence it is required to guarantee that at most one process is in the critical section at a time. These algorithms aim to solve mutual exclusion with no deadlocks, no starvation, and some notion of fairness.
Assertion-Based Mutual Exclusion A process has to request permission from all or part of the other processes and based on their replies it may conclude that is the only one with rights to enter its CS.</description>
    </item>
    
    <item>
      <title>Deadlock Detection</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/deadlockdetection/</link>
      <pubDate>Sun, 17 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/deadlockdetection/</guid>
      <description>Models for Deadlock A (directed) Wait-For-Graph (WFG) can be maintained with the processes as nodes and with an edge from process $P$ to process $Q$ when $Q$ is holding a resource that $P$ is requesting.
In the resource mode resources are associated with a process (e.g. $R_a$) anf processes can then request said resource. When a process $P$ wants access to a resource $a$ from $R_a$, an edge is created from $P$ to $R_a$, and when the resource is granted, the edge is removed and replaced by an edge from $R_a$ to $P$ indicating that $R_a$ is waiting for $P$ to release the resource.</description>
    </item>
    
    <item>
      <title>Lecture 12: Secret Sharing</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-12/</link>
      <pubDate>Sat, 16 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-12/</guid>
      <description>Secret Sharing (Chapter 19) Threshold Cryptography split key into shares and a certain number of then can reconstruct the secret key. Or performing operations jointly (decryption, signing, etc.) but the secret key is not known to anyone (e.g. group signatures).
Dealer $(D)$ has the secret key $s$ and provides the shares to different parties $P_1,...,P_n$
Distribution: Protocol in which the dealer provides each party $P_i$ a share $s_i$.
Reconstruction: Protocol in which a qualified set of parties pool their shares to obtain secret $s$.</description>
    </item>
    
    <item>
      <title>Termination Detection</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/terminationdetection/</link>
      <pubDate>Sat, 16 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/terminationdetection/</guid>
      <description>Termination detection is the problem of determining whether a distributed computation in a distributed system consisting of processes which communicate by means of message, has terminated.
Distributed computations have the following properties:
 A process is either active or passive Only active processes can send messages An active process may become passive spontaneously A passive process becomes active ate the reception of a message  Termination Detection in an Asynchronous Unidirectional Ring with FIFO Communication There exits a process $P_{0}$ that is on top of the ring and other processes are connected to it in the order of $P_{n-1}$ to the right of $P_0$ and $P_1$ to the left.</description>
    </item>
    
    <item>
      <title>Global States</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/globalstates/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/globalstates/</guid>
      <description>Detecting of global states is the recording of an asynchronous system at some point in time for checkpointing or detecting stable properties such as deadlock or termination.
A cut presents a set of internal events and can be considered consistent (when receiving events happens after sending events) or inconsistent (when receiving events happen without the send events).

Chandy&#39;s and Lamport&#39;s algorithm for detecting global states in distributed systems with unidirectional FIFO channels Any processor wishing to record the global state of the system first records its own local state and then sends a marker on every outgoing channel.</description>
    </item>
    
    <item>
      <title>Lecture 11: Certificates, Key Transport, and Key Agreement</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-11/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-11/</guid>
      <description>Certificates, Key Transport, and Key Agreement (Chapter 18) What is key management?
 Key generation Key distribution Key storage Key change Key usage Key destruction  Requirements of key generation:
 secret unpredictable strong key  It is often desirable to frequently change the key in a cryptographic system.
Types of keys:
 Static (or Long Term) Keys: few hours to a few years Ephemeral or Session (or Short Term) Keys a few seconds or a day  Certificates and Certificate Authority We need a binding, linking a public key to an entity.</description>
    </item>
    
    <item>
      <title>Lecture 10: Public Key Encryption and Signature Algorithms</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-10/</link>
      <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-10/</guid>
      <description>Public Key Encryption and Signature Algorithms (Chapter 16) Passively Secure Encryption Schemes Goldwasser Micali Encryption Is based on the QUADRES problem, stating that given a composite integer $N$ and an integer $e$, it is hard to test if $a$ is a quadratic residue or not. This is given as checking if a value from the set $J_N$ of values that produce a jacobi symbol of 1 (hence might be quadratic residue) is in the set of real quadratic residues $Q_N$.</description>
    </item>
    
    <item>
      <title>Message Ordering</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/messageodering/</link>
      <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/messageodering/</guid>
      <description>In asynchronous systems messages may have arbitrary but finite delays but the applications may impose some kind of ordering on the messages (causal order). Multicasting is when a message is sent to group of processes rather than just to a single process.
Ordering A message order is causal when for every two messages $m_1$ and $m_2$, if $m(m_1)\rightarrow m(m_2)$ then $d_i(d_1)\rightarrow d_i(d_2)$ for all $i\in Dest(m_1)\cap Dest(m_2)$.
A message order is total when for every two messages $m_1$ and $m_2$, $d_i(m_1)\rightarrow d_i(m_2)$ iff $d_j(m_1)\rightarrow d_j(m_2)$ for all $i,j \in Dest(m_1) \cap Dest(m_1)$.</description>
    </item>
    
    <item>
      <title>Lecture 9: The RSA Algorithm</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-9/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-9/</guid>
      <description>The RSA Algorithm (Chapter 15) The RSA algorithm is based on the difficulty of the RSA problem that it is difficult to to find $d$ given a large composite number $N$ and $e$. It works by taking two large secret prime numbers $p$ and $q$ and computing $N=p*q$. Then picking an encryption exponent $e$ that satisfies
\[\text{gcd}(e,(p-1)*(q-1))=1\]
It is common to chose values $e=3,17,65537$. Now the public key will be shared as the pair of $\mathfrak{pC}=(N,e)$.</description>
    </item>
    
    <item>
      <title>Synchronizers</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/synchronizers/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/synchronizers/</guid>
      <description>Synchronizers are algorithms that simulate synchronous systems on top of asynchronous systems. They proceed in rounds of sending messages, receiving messages, and performing local computations, and these algorithms work on the foundation of issuing a pulse (clock) to allow a process to move to the next round.
Types of Synchronizers Alpha Synchronizer In $\alpha$-synchronizers, when a node receives a message, it sends an ACK message back to the sender. When a process received an ACK for every message it has sent in some round, it is called safe.</description>
    </item>
    
    <item>
      <title>Lecture 8: Number Theory and Elliptic Curves</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-8/</link>
      <pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-8/</guid>
      <description>Number Theory and Elliptic Curves (Chapter 1 &amp;amp; 4) Modular Arithmetic A positive integer $N$ called modulus is written as
\[a=b\text{ mod }N\]
if $N$ divides $b-a$, $a$ and $b$ are congruent modulo $N$.
The set of values produced by postfix operation mod $N$ is $\mathbb{Z}_N=\{0,1,...,N-1\}$ (can also be written as $\mathbb{Z}/N\mathbb{Z}$).
The properties of modulo arithmetic are

A group is a set which is closed, has an identity, is associative, and every element has an inverse.</description>
    </item>
    
    <item>
      <title>Time Concepts</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/timeconcepts/</link>
      <pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/timeconcepts/</guid>
      <description>Time has an important role in computer systems, the applications that they run need to be able to keep track of time and events and compare timestamps. In asynchronous systems it may be necessary to reason about events based on their order of occurrence.
Happened-Before Relation The basis of the theory of ordering events in distributed systems is the happened-before relation, and is given as $\rightarrow$ as the following
 Local Order: If $a,b\in E_i$ for $i$ and $a$ occurred in $P_i$ before $b$ then $a\rightarrow b$.</description>
    </item>
    
    <item>
      <title>Lecture 7: Hash Functions, MAC, and Key Derivation Functions</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-7/</link>
      <pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-7/</guid>
      <description>Hash Functions, MAC, and Key Derivation Functions (Chapter 14) Hash functions are used for integrity protection (checksum, file system integrity like Bit-torrent), one way encryption (password protection), asymmetric crypto schemes, MACs, key derivations, pseudo random number generators, and many more applications.
Hash functions receive an arbitrary length bit string and output a fixed length string called the hash value, digest, fingerprint, or hashcode. Hash functions are one way: easy to compute $y$ given $x$, where $y: H: \{0-1\}*\rightarrow\{0-1\}^n$</description>
    </item>
    
    <item>
      <title>Modeling Distributed Systems</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/modelingds/</link>
      <pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/modelingds/</guid>
      <description>DSs and DAs are modelled with a set of processors or processes, which do local computations and send and receive messages, and are connected by unidirectional communication channels, and networks are assumed to be connected such that there is a path from every process to every other process.
In a complete network there is a link from every processor to every other processor. In ring every processor is connected to two other processors.</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/introduction/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/introduction/</guid>
      <description>What is a Distributed System? Distributed computer systems are collections of computer systems that present themselves as single entities to their users and are characterized by
 Autonomy: The components of the DS have a certain power or authority to make their own decisions. Cooperation: The components iof a DS are working together towards common goals. Communication: The components of the DS exchange information.  Properties of Distributed Systems  There is no regular structure such that a DS may be connected by heterogenous network technologies and consist of many different processors.</description>
    </item>
    
    <item>
      <title>Lecture 6: Block Ciphers and Modes of Operation</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-6/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-6/</guid>
      <description>Block Ciphers and Modes of Operation (Chapter 13) Block ciphers operate on blocks of plaintext at a time to produce blocks of ciphertext. Block sizes tend to be large, 64 bits in DES and 128 bits in other modern block ciphers. In order to limit the advantage of the adversary, the key space is kept very large such that $Adv_{{F_k}K}^{PRP}(A)\approx 1/|K|$. Block cipher is part of an encryption but requires a mode of operation, these are both developed independently.</description>
    </item>
    
    <item>
      <title>Lecture 5: Modern Stream Ciphers</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-5/</link>
      <pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-5/</guid>
      <description>Modern Stream Ciphers (Chapter 12) Encrypt bits rather than blocks as this is faster and easier to implement in hardware and software. Stream ciphers work by
\[c=m\oplus F_k(0)\]
and are IND-PASS secure if the PRF is secure.
Feedback shift registers are a standard way of producing a binary stream of data. These consist of a number of memory cells, where some of them are tapped that feed a feedback function. Registers are shifted down and the result from the feedback is shifted to the empty cell.</description>
    </item>
    
    <item>
      <title>Lecture 4: Defining Security</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-4/</link>
      <pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-4/</guid>
      <description>Security Games (Chapter 2.2) Security games are used to define security for cryptographic components, which contain an adversary and a challenger, and the idea is that the adversary needs to reach a certain objective given data provided by the challenger. These are typically represented visually with the adversary in a box and the challenger outside with the data it provides. The advantage of an adversary \(A\) is defined as a function bounded by time \(t\) that the adversary spends to try to solve the problem.</description>
    </item>
    
    <item>
      <title>Lecture 3: Information Theoretic Security</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-3/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-3/</guid>
      <description>Information Theoretic Security (Chapter 9) A crypto system is said to be computationally secure if the best possible algorithm for breaking it requires \(N\) operations, where \(N\) is some large number above $2^{128}$. It is impossible to prove that a system is computationally secure, as we do not know if there is a better algorithm for breaking it, hence a system is called secure if the best known algorithm requires a large number of computations.</description>
    </item>
    
    <item>
      <title>Lecture 2: Classical Systems</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-2/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-2/</guid>
      <description>Classical Systems (Chapter 7) An encryption algorithm or cipher is the transformation of plaintext to ciphertext with a secret key, depicted as
\[c=e_k(m)\]
with $m$ being the plaintext,
$e$ being the cipher function,
$k$ being the secret key,
$c$ being the ciphertext
The reverse process is called decryption or decipherment, depicted as
\[m=d_k(c)\]
The key above needs to be known to both parties, but must be kept secret from all others.</description>
    </item>
    
    <item>
      <title>Lecture 1: Introduction</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-1/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-1/</guid>
      <description>What is Security? Security means:
Confidentiality: Access to systems or data is limited to authorized parties.
Integrity: When you receive data, you get the &amp;quot;right&amp;quot; data.
Availability: The system or data is there when you want it.
Objectives of Cryptography - Message authentication: valid message? - Data origin authentication: valid sender? - Entity authentication: authenticate each other for communication  Kerckhoff&#39;s principle: The adversary knows all details about the crypto system except the private key.</description>
    </item>
    
    <item>
      <title>Info</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/info/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/info/</guid>
      <description>IN4150 Distributed Algorithms notes at TUDelft (Q2).
Studyguide: https://studiegids.tudelft.nl/a101_displayCourse.do?course_id=55229
All content and images are based on and retrieved from the slides and the provided lecture notes for the course.</description>
    </item>
    
    <item>
      <title>Info</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/info/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/info/</guid>
      <description>IN4191 Security and Cryptography notes at TUDelft (Q1).
Studyguide: https://studiegids.tudelft.nl/a101_displayCourse.do?course_id=55221
Book: Nigel P. Smart. 2015. Cryptography Made Simple (1st. ed.). Springer Publishing Company, Incorporated.
All content and images are based on and retrieved from the book and the lecture slides.</description>
    </item>
    
    <item>
      <title>Active Projects</title>
      <link>https://nicktehrany.github.io/active-projects/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/active-projects/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Amsterdam Data Science Thesis Award</title>
      <link>https://nicktehrany.github.io/publications/amsterdam-data-science-thesis-award/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/publications/amsterdam-data-science-thesis-award/</guid>
      <description>For my BSc Computer Science Thesis I received the Amsterdam Data Science Thesis award. The thesis was completed in 2020 at the Vrije Universiteit Amsterdam with @Large Massivizing Computer Systems research group. The full thesis is available here and more information on the Amsterdam Data Science award can be found here.</description>
    </item>
    
    <item>
      <title>IN4150 Distributed Algorithms</title>
      <link>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/</link>
      <pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4150-distributed-algorithms-notes/</guid>
      <description></description>
    </item>
    
    <item>
      <title>textemp</title>
      <link>https://nicktehrany.github.io/completed-projects/textemp/</link>
      <pubDate>Sun, 08 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/completed-projects/textemp/</guid>
      <description>I was tired of having to create new folder structure and latex files every time I had to create a new latex project (which was quite often). Therefore I made a quick and simple command to set up the basic directory structure and initialize the .tex files with the most basic necessities.
Setup Clone the repo anywhere you like,
git clone https://github.com/nicktehrany/textemp  Source the textemp script in your .</description>
    </item>
    
    <item>
      <title>IN4191 Security and Cryptography</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/</link>
      <pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/</guid>
      <description></description>
    </item>
    
    <item>
      <title>BSc Computer Science Thesis</title>
      <link>https://nicktehrany.github.io/thesis/bsc-computer-science-thesis/</link>
      <pubDate>Tue, 25 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/thesis/bsc-computer-science-thesis/</guid>
      <description>&amp;ldquo;Evaluating Performance Characteristics of the PMDK Persistent Memory Software Stack&amp;rdquo; Abstract: Society nowadays revolves more and more around data. Data Science, Machine Learning, and Artificial Intelligence depend on large amounts of data to conduct research, and train machine learning models and agents. With the ever increasing amount of data, comes the need for faster storage. The quest for new storage devices has resulted in the development of non-volatile memories, that run alongside conventional memory and are directly accessible by the CPU, with large capacity of persistent storage.</description>
    </item>
    
    <item>
      <title>Completed Projects</title>
      <link>https://nicktehrany.github.io/completed-projects/</link>
      <pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/completed-projects/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Dotfiles</title>
      <link>https://nicktehrany.github.io/active-projects/dotfiles/</link>
      <pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/active-projects/dotfiles/</guid>
      <description>My dotfiles repository, which is more of a continuous project likely to never be done, for managing all my config files for vim, zsh, tmux, git, other dotfiles and utilities I use.
Installation git clone https://github.com/nicktehrany/dotfiles cd dotfiles sudo ./install  Check the .packages.conf.yaml for packages that will be installed, if not already installed. All existing links or config files will be overwritten! (Check .install.conf.yaml for all links)</description>
    </item>
    
  </channel>
</rss>