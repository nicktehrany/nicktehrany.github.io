<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IN4191 Security and Cryptography Notes on Nick Tehrany</title>
    <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/</link>
    <description>Recent content in IN4191 Security and Cryptography Notes on Nick Tehrany</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 16 Jan 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://nicktehrany.github.io/in4191-security-and-cryptography-notes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Lecture 12: Secret Sharing</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-12/</link>
      <pubDate>Sat, 16 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-12/</guid>
      <description>Secret Sharing (Chapter 19) Threshold Cryptography split key into shares and a certain number of then can reconstruct the secret key. Or performing operations jointly (decryption, signing, etc.) but the secret key is not known to anyone (e.g. group signatures).
Dealer $(D)$ has the secret key $s$ and provides the shares to different parties $P_1,...,P_n$
Distribution: Protocol in which the dealer provides each party $P_i$ a share $s_i$.
Reconstruction: Protocol in which a qualified set of parties pool their shares to obtain secret $s$.</description>
    </item>
    
    <item>
      <title>Lecture 11: Certificates, Key Transport, and Key Agreement</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-11/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-11/</guid>
      <description>Certificates, Key Transport, and Key Agreement (Chapter 18) What is key management?
 Key generation Key distribution Key storage Key change Key usage Key destruction  Requirements of key generation:
 secret unpredictable strong key  It is often desirable to frequently change the key in a cryptographic system.
Types of keys:
 Static (or Long Term) Keys: few hours to a few years Ephemeral or Session (or Short Term) Keys a few seconds or a day  Certificates and Certificate Authority We need a binding, linking a public key to an entity.</description>
    </item>
    
    <item>
      <title>Lecture 10: Public Key Encryption and Signature Algorithms</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-10/</link>
      <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-10/</guid>
      <description>Public Key Encryption and Signature Algorithms (Chapter 16) Passively Secure Encryption Schemes Goldwasser Micali Encryption Is based on the QUADRES problem, stating that given a composite integer $N$ and an integer $e$, it is hard to test if $a$ is a quadratic residue or not. This is given as checking if a value from the set $J_N$ of values that produce a jacobi symbol of 1 (hence might be quadratic residue) is in the set of real quadratic residues $Q_N$.</description>
    </item>
    
    <item>
      <title>Lecture 9: The RSA Algorithm</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-9/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-9/</guid>
      <description>The RSA Algorithm (Chapter 15) The RSA algorithm is based on the difficulty of the RSA problem that it is difficult to to find $d$ given a large composite number $N$ and $e$. It works by taking two large secret prime numbers $p$ and $q$ and computing $N=p*q$. Then picking an encryption exponent $e$ that satisfies
\[\text{gcd}(e,(p-1)*(q-1))=1\]
It is common to chose values $e=3,17,65537$. Now the public key will be shared as the pair of $\mathfrak{pC}=(N,e)$.</description>
    </item>
    
    <item>
      <title>Lecture 8: Number Theory and Elliptic Curves</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-8/</link>
      <pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-8/</guid>
      <description>Number Theory and Elliptic Curves (Chapter 1 &amp;amp; 4) Modular Arithmetic A positive integer $N$ called modulus is written as
\[a=b\text{ mod }N\]
if $N$ divides $b-a$, $a$ and $b$ are congruent modulo $N$.
The set of values produced by postfix operation mod $N$ is $\mathbb{Z}_N=\{0,1,...,N-1\}$ (can also be written as $\mathbb{Z}/N\mathbb{Z}$).
The properties of modulo arithmetic are

A group is a set which is closed, has an identity, is associative, and every element has an inverse.</description>
    </item>
    
    <item>
      <title>Lecture 7: Hash Functions, MAC, and Key Derivation Functions</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-7/</link>
      <pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-7/</guid>
      <description>Hash Functions, MAC, and Key Derivation Functions (Chapter 14) Hash functions are used for integrity protection (checksum, file system integrity like Bit-torrent), one way encryption (password protection), asymmetric crypto schemes, MACs, key derivations, pseudo random number generators, and many more applications.
Hash functions receive an arbitrary length bit string and output a fixed length string called the hash value, digest, fingerprint, or hashcode. Hash functions are one way: easy to compute $y$ given $x$, where $y: H: \{0-1\}*\rightarrow\{0-1\}^n$</description>
    </item>
    
    <item>
      <title>Lecture 6: Block Ciphers and Modes of Operation</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-6/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-6/</guid>
      <description>Block Ciphers and Modes of Operation (Chapter 13) Block ciphers operate on blocks of plaintext at a time to produce blocks of ciphertext. Block sizes tend to be large, 64 bits in DES and 128 bits in other modern block ciphers. In order to limit the advantage of the adversary, the key space is kept very large such that $Adv_{{F_k}K}^{PRP}(A)\approx 1/|K|$. Block cipher is part of an encryption but requires a mode of operation, these are both developed independently.</description>
    </item>
    
    <item>
      <title>Lecture 5: Modern Stream Ciphers</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-5/</link>
      <pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-5/</guid>
      <description>Modern Stream Ciphers (Chapter 12) Encrypt bits rather than blocks as this is faster and easier to implement in hardware and software. Stream ciphers work by
\[c=m\oplus F_k(0)\]
and are IND-PASS secure if the PRF is secure.
Feedback shift registers are a standard way of producing a binary stream of data. These consist of a number of memory cells, where some of them are tapped that feed a feedback function. Registers are shifted down and the result from the feedback is shifted to the empty cell.</description>
    </item>
    
    <item>
      <title>Lecture 4: Defining Security</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-4/</link>
      <pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-4/</guid>
      <description>Security Games (Chapter 2.2) Security games are used to define security for cryptographic components, which contain an adversary and a challenger, and the idea is that the adversary needs to reach a certain objective given data provided by the challenger. These are typically represented visually with the adversary in a box and the challenger outside with the data it provides. The advantage of an adversary \(A\) is defined as a function bounded by time \(t\) that the adversary spends to try to solve the problem.</description>
    </item>
    
    <item>
      <title>Lecture 3: Information Theoretic Security</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-3/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-3/</guid>
      <description>Information Theoretic Security (Chapter 9) A crypto system is said to be computationally secure if the best possible algorithm for breaking it requires \(N\) operations, where \(N\) is some large number above $2^{128}$. It is impossible to prove that a system is computationally secure, as we do not know if there is a better algorithm for breaking it, hence a system is called secure if the best known algorithm requires a large number of computations.</description>
    </item>
    
    <item>
      <title>Lecture 2: Classical Systems</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-2/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-2/</guid>
      <description>Classical Systems (Chapter 7) An encryption algorithm or cipher is the transformation of plaintext to ciphertext with a secret key, depicted as
\[c=e_k(m)\]
with $m$ being the plaintext,
$e$ being the cipher function,
$k$ being the secret key,
$c$ being the ciphertext
The reverse process is called decryption or decipherment, depicted as
\[m=d_k(c)\]
The key above needs to be known to both parties, but must be kept secret from all others.</description>
    </item>
    
    <item>
      <title>Lecture 1: Introduction</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-1/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/lecture-1/</guid>
      <description>What is Security? Security means:
Confidentiality: Access to systems or data is limited to authorized parties.
Integrity: When you receive data, you get the &amp;quot;right&amp;quot; data.
Availability: The system or data is there when you want it.
Objectives of Cryptography - Message authentication: valid message? - Data origin authentication: valid sender? - Entity authentication: authenticate each other for communication  Kerckhoff&#39;s principle: The adversary knows all details about the crypto system except the private key.</description>
    </item>
    
    <item>
      <title>Info</title>
      <link>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/info/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nicktehrany.github.io/in4191-security-and-cryptography-notes/info/</guid>
      <description>IN4191 Security and Cryptography notes at TUDelft (Q1).
Studyguide: https://studiegids.tudelft.nl/a101_displayCourse.do?course_id=55221
Book: Nigel P. Smart. 2015. Cryptography Made Simple (1st. ed.). Springer Publishing Company, Incorporated.
All content and images are based on and retrieved from the book and the lecture slides.</description>
    </item>
    
  </channel>
</rss>