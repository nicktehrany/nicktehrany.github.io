<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IN4191 Security and Cryptography on Nick Tehrany</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/</link><description>Recent content in IN4191 Security and Cryptography on Nick Tehrany</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 30 Sep 2020 08:34:56 -0600</lastBuildDate><atom:link href="https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Lecture 12: Secret Sharing</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-12/</link><pubDate>Sat, 16 Jan 2021 00:00:00 +0000</pubDate><guid>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-12/</guid><description>Secret Sharing (Chapter 19) Threshold Cryptography split key into shares and a certain number of then can reconstruct the secret key. Or performing operations jointly (decryption, signing, etc.) but the secret key is not known to anyone (e.g. group signatures).
Dealer $(D)$ has the secret key $s$ and provides the shares to different parties $P_1,&amp;hellip;,P_n$
Distribution: Protocol in which the dealer provides each party $P_i$ a share $s_i$.
Reconstruction: Protocol in which a qualified set of parties pool their shares to obtain secret $s$.</description><content type="html"><![CDATA[<h2 id="secret-sharing-chapter-19">Secret Sharing (Chapter 19)</h2>
<p><strong>Threshold Cryptography</strong> split key into shares and a certain number of then can reconstruct the secret key. Or performing operations jointly (decryption, signing, etc.) but the secret key is not known to anyone (e.g. group signatures).</p>
<p>Dealer $(D)$ has the secret key $s$ and provides the shares to different parties $P_1,&hellip;,P_n$</p>
<p>Distribution: Protocol in which the dealer provides each party $P_i$ a share $s_i$.</p>
<p>Reconstruction: Protocol in which a qualified set of parties pool their shares to obtain secret $s$.</p>
<p>Access structure: The collection of all groups of parties that can reconstruct.</p>
<h3 id="shamir-secret-sharing">Shamir Secret Sharing</h3>
<p>A dealer first creates a secret polynomial of degree $t$ and gives out points on the graph to parties, and in oder to reconstruct, the points of $t+1$ parties need to come together to reconstruct the polynomial and recover the secret (intercept of $y$ in the graph). Since the $y$-intercept is the secret, the point at $x=0$ is not given out.</p>
<h3 id="rsa-shared-signature">RSA Shared Signature</h3>
<p>$(t,n)$ RSA threshold scheme that uses a polynomial of degree $t-1$ and a prime $e$ such that $e&gt;n$. Then</p>
<ol>
<li>compute points on the polynomial</li>
<li>each server signs partially a document</li>
<li>user received the shared and constructs the signature from $t$ shares</li>
</ol>
<p><img src="/images/IN4191/RSA-Secret-Share.png" alt="RSA Shared Signature"></p>
]]></content></item><item><title>Lecture 11: Certificates, Key Transport, and Key Agreement</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-11/</link><pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate><guid>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-11/</guid><description>Certificates, Key Transport, and Key Agreement (Chapter 18) What is key management?
Key generation Key distribution Key storage Key change Key usage Key destruction Requirements of key generation:
secret unpredictable strong key It is often desirable to frequently change the key in a cryptographic system.
Types of keys:
Static (or Long Term) Keys: few hours to a few years Ephemeral or Session (or Short Term) Keys a few seconds or a day Certificates and Certificate Authority We need a binding, linking a public key to an entity.</description><content type="html"><![CDATA[<h2 id="certificates-key-transport-and-key-agreement-chapter-18">Certificates, Key Transport, and Key Agreement (Chapter 18)</h2>
<p>What is key management?</p>
<ul>
<li>Key generation</li>
<li>Key distribution</li>
<li>Key storage</li>
<li>Key change</li>
<li>Key usage</li>
<li>Key destruction</li>
</ul>
<p>Requirements of key generation:</p>
<ul>
<li>secret</li>
<li>unpredictable</li>
<li>strong key</li>
</ul>
<p>It is often desirable to frequently change the key in a cryptographic system.</p>
<p>Types of keys:</p>
<ul>
<li><strong>Static (or Long Term) Keys:</strong> few hours to a few years</li>
<li><strong>Ephemeral or Session (or Short Term) Keys</strong> a few seconds or a day</li>
</ul>
<h3 id="certificates-and-certificate-authority">Certificates and Certificate Authority</h3>
<p>We need a binding, linking a public key to an entity. This is achieved for physical tokens such as smart cards with biometrics or PINs, and otherwise we can use digital certificates.</p>
<p>This requires a trusted third party (TTP) or a certificate authority (CA).</p>
<p>The system of CAs and certificates is called the Public Key Infrastructure (PKI).</p>
<h4 id="implicit-certificates">Implicit Certificates</h4>
<p>Typical certificates are large which can be undesirable in small systems and therefore we can have smaller certificates that bind the public key and the data in the form of $X|Y$ where $X$ is the data being bound to the public key and $Y$ is the implicit certificate on $X$.</p>
<h4 id="fresh-ephemeral-symmetric-keys-form-static-symmetric-keys">Fresh Ephemeral Symmetric Keys form Static Symmetric Keys</h4>
<p>Derive short term keys form long term keys using symmetric systems.
Definitions:</p>
<ul>
<li>Parties: A, B, and TTP</li>
<li>Shared Keys: $K_{ab}$,$K_{bs}$, $K_{as}$</li>
<li>Nonces: numbers used only once, unique but not necessarily random</li>
<li>Timestamps: $T_a$, $T_b$</li>
</ul>
<p>$$A\rightarrow B: \color{blue}{M,A,B,}\{\color{red}{N_a,M,A,B}\}\color{red}{K_{as}}$$</p>
<p><strong>Wide-Mouth Frog Protocol</strong></p>
<p><img src="/images/IN4191/Wide-Mouth-Frog.png" alt="Wide-Mouth Frog Protocol"></p>
<p>Problem of replay attacks if clocks are not synchronized.</p>
<p><strong>Needham-Schroeder Protocol</strong></p>
<p><img src="/images/IN4191/Needham_schroeder.png" alt="Needham-Schroeder Protocol"></p>
<p><strong>Kerberos</strong></p>
<p>Authentication system is based on symmetric encryption, and it uses timestamps with synchronized clocks (a requirement that clocks are synced).</p>
<p><img src="/images/IN4191/Kerberos.png" alt="Kerberos"></p>
<h4 id="fresh-ephemeral-symmetric-keys-from-static-public-keys">Fresh Ephemeral Symmetric Keys from Static Public Keys</h4>
<p>Problem that TTP based solution assume that there is a shared long term key, solving this can be done in two ways, key transport based on public key cryptography, or kry agreement that outputs a symmetric key.</p>
<p>Alice sends the symmetric key to Bob by encrypting it with Bob&rsquo;s public key.</p>
<p><img src="/images/IN4191/key-transport.png" alt="Key Transport"></p>
<p><strong>Forward secrecy:</strong> a compromise on a key should not lead to security problems on the previous messages decrypted before that time.</p>
<h4 id="diffie-hellman-key-exchange-protocol">Diffie-Hellman Key Exchange Protocol</h4>
<p>It enables two entities to establish a symmetric key even though they have never met before, based on the discrete log problem, and works with a finite field version on abelian group $G$ of order $q$, and an elliptic curve version.</p>
<p><img src="/images/IN4191/Diffie-Hellman-Key-Exchange.png" alt="Diffie-Hellman Key Exchange"></p>
<p>Has the problem of man in the middle attacks.</p>
<p><img src="/images/IN4191/Signed-Diffie-Hellman.png" alt="Signed Diffie-Hellman Key Exchange"></p>
<p>Signed is still not secure as the attacker can change the signature. The randomness of $g^a$ or $g^b$ is not linked with the ID of the sender.</p>
<h4 id="station-to-station-sts-protocol">Station-to-Station (STS) Protocol</h4>
<p><img src="/images/IN4191/STS.png" alt="STS"></p>
<h4 id="blake-wilson-menezes-protocol">Blake-Wilson-Menezes Protocol</h4>
<p>Achieving authentication without signatures and MACs. It assumes that Alice and Bob have long term keys $(g^a,a)$ and $(g^b,b)$ respectively, and they obtain each others public key via certificates, then</p>
<p>$$A\rightarrow B: \mathfrak{ek}_A=g^x$$</p>
<p>$$B\rightarrow A: \mathfrak{ek}_B=g^y$$</p>
<p>Then Alice computes</p>
<p>$$k\leftarrow H(\mathfrak{pk}_B^x,\mathfrak{ek}_B^a)=H(g^{b<em>x},g^{y</em>a})$$</p>
<p>Bob computes</p>
<p>$$k\leftarrow H(\mathfrak{ek}_A^b,\mathfrak{pk}_A^y)=H(g^{x<em>b},g^{a</em>y})$$</p>
]]></content></item><item><title>Lecture 10: Public Key Encryption and Signature Algorithms</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-10/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-10/</guid><description>Public Key Encryption and Signature Algorithms (Chapter 16) Passively Secure Encryption Schemes Goldwasser Micali Encryption Is based on the QUADRES problem, stating that given a composite integer $N$ and an integer $e$, it is hard to test if $a$ is a quadratic residue or not. This is given as checking if a value from the set $J_N$ of values that produce a jacobi symbol of 1 (hence might be quadratic residue) is in the set of real quadratic residues $Q_N$.</description><content type="html"><![CDATA[<h2 id="public-key-encryption-and-signature-algorithms-chapter-16">Public Key Encryption and Signature Algorithms (Chapter 16)</h2>
<h3 id="passively-secure-encryption-schemes">Passively Secure Encryption Schemes</h3>
<h4 id="goldwasser-micali-encryption">Goldwasser Micali Encryption</h4>
<p>Is based on the QUADRES problem, stating that given a composite integer $N$ and an integer $e$, it is hard to test if $a$ is a quadratic residue or not. This is given as checking if a value from the set $J_N$ of values that produce a jacobi symbol of 1 (hence might be quadratic residue) is in the set of real quadratic residues $Q_N$.</p>
<p>Key generation is done with $N=p*q$ two prime numbers and $y\in J_N \text{\\} Q_N$ (The set of pseudo-squares is the difference between the two sets). The secret key is given as $\mathfrak{sK}=(p,q)$ and the public key as $\mathfrak{pK}=(N,y)$.</p>
<p><img src="/images/IN4191/Goldwasser-Micali.png" alt="Goldwasser-Micali"></p>
<p>Encryption is for a single bit $b$ done by choosing a value</p>
<p>$$x\leftarrow \mathbb{Z}_N^*$$</p>
<p>and then computing</p>
<p>$$c\leftarrow y^b*x^2\text{ mod }N$$</p>
<p>Decryption is done by computing the legendre symbol of the ciphertext $(\frac{c}{p})$. If $b=0$, $c$ is a quadratic residue (+1), if $b=1$, $c$ is non-quadratic residue (-1). This scheme is very inefficient as you can only encrypt binary values one at a time.</p>
<p>It <strong>is IND-CPA</strong> secure as it is probabilistic and not deterministic due to choosing a new value $x$ and having a different ciphertext for the same plaintext every time.</p>
<p>It is <strong>not IND-CCA</strong> secure since the system is homomorphic, meaning an operation in the ciphertext domain corresponds to an operation in the plaintext domain (binary addition, which is xor).</p>
<h4 id="elgamal-encryption">ElGamal Encryption</h4>
<p>It uses a prime number $p$ such that $p-1$ is divisible by another prime number $q$, and element $g$ is an element in the finite field $p$ with an order $q$.</p>
<p>Key generation is done as secret key is $x\leftarrow [0,&hellip;,q-1]$ and public key is $h\leftarrow g^x\text{ mod }p$.</p>
<p>Encryption message $m$ in $G$ is done as generating randomness</p>
<p>$$k\leftarrow \{0,&hellip;,q-1\}$$</p>
<p>ciphertext</p>
<p>$$c_1\leftarrow g^k$$</p>
<p>$$c_2\leftarrow m*h^k$$</p>
<p>and output ciphertext</p>
<p>$$c\leftarrow (c_1,c_2)\in G*G$$</p>
<p>Decrypting $c=(c_1,c_2)$ is done as</p>
<p>$$\frac{c_2}{c_1\text{}^x}=\frac{m<em>h^k}{g^{x</em>k}}=\frac{m<em>g^{x</em>k}}{g^{x*k}}=m$$</p>
<p>It <strong>is IND-CPA</strong> secure but <strong>not IND-CCA</strong> secure due to multiplicative homomorphism.</p>
<p>This scheme introduces data expansion as the message with the ciphertext will have two pieces.</p>
<h4 id="carmichael-theorem">Carmichael Theorem</h4>
<p>Let $n=pq$ where $p$ and $q$ are large numbers, $\phi(n)$ is Euler&rsquo;a totient function and $\lambda(n)=lcm(p-1,q-1)$. For any</p>
<p>$$w\in \mathbb{Z}_{n^2}^*$$</p>
<p>$$w^\lambda=1\text{ mod }n$$</p>
<p>$$w^{n\lambda}=1\text{ mod }n^2$$</p>
<h4 id="pallier-encryption">Pallier Encryption</h4>
<p>Based on the difficulty of factoring large integers. Key generation is done with $n=p*q$ and $g$ is a generator of the group</p>
<p>$$\mathbb{Z}_{N^2}^*$$</p>
<p>with an order of $n$ that is $g^n\equiv 1\text{ mod } n^2$ and $\lambda =lcm(p-1,q-1)$ (least common multiplier), where the secret key is $\lambda$ and the public key is $(g,n)$.</p>
<p>Encryption is done as</p>
<p>$$m\in \mathbb{Z}_N\text{ and }r\in_R\mathbb{Z}_N^*$$</p>
<p>$$E_{pk}(m)=g^mr^n\text{ mod }n^2$$</p>
<p>Decryption is done as</p>
<p>$$D_{sk}(c)=\frac{L(c^\lambda\text{ mod }n^2)}{L(g^\lambda\text{ mod }n^2)}\text{ mod }n$$</p>
<p>where $L(u)=\frac{u-1}{n}$.</p>
<p>It is probabilistic, hence it <strong>is IND-CPA</strong> secure, <strong>not IND-CCA</strong> secure since it is additively homomorphic (multiplication in the ciphertext corresponds to addition in the plaintext domain).</p>
<h4 id="rsa-oaep-optimized-asymmetric-encryption-padding">RSA-OAEP (Optimized Asymmetric Encryption Padding)</h4>
<p><img src="/images/IN4191/OAEP.png" alt="OAEP"></p>
<p>Function $f$ is any $k$-bit trapdoor one way permutation, $k_0$ and $k_1$ are numbers such that the effort of $2^{k_0}$ and $2^{k_1}$ is impossible ($k_0,k_1&gt;128$ bits). $n=k-k_0-k_1$ and the hash functions</p>
<p>$$G:\{0,1\}^{k_0}\rightarrow \{0,1\}^{n+k_1}$$</p>
<p>$$H:\{0,1\}^{n+k_1}\rightarrow \{0,1\}^{k_0}$$</p>
<p>with message $m$ of $n$ bits then</p>
<p>$$c\leftarrow E(m)=f(\{(m||0^{k_1})\oplus G(R)\}||\{R\oplus H((m||0^{k_1})\oplus G(R))\})=f(A)$$</p>
<p>Decryption is done as</p>
<p><img src="/images/IN4191/OAEP-Decrypt.png" alt="OAEP Decryption"></p>
<p>It <strong>is IND-CCA</strong> secure and <strong>is IND-CPA</strong> secure.</p>
<h4 id="fujisaki-okamoto-transform">Fujisaki-Okamoto Transform</h4>
<p>Using this transform to obtain IND-CCA secure schemes from IND-CPA secure schemes.</p>
<p>$$\text{Original scheme: }E(m,r)$$</p>
<p>$$\text{new scheme: }E&rsquo;(m,r)=E(m||r,H(m||r))$$</p>
<h3 id="hybrid-systems">Hybrid Systems</h3>
<p>In practice the KEM/DEM approach is used, meaning that data will be encrypted using a symmetric cipher and the key of the encryption is sent using an asymmetric cipher.</p>
<p><strong>KEM:</strong> Key encapsulation mechanism (public key component)</p>
<p><strong>DEM:</strong> Data encapsulation mechanism (private key component)</p>
<p>To encrypt a message $m$ to a user with $(\mathfrak{pk,sk})$, do</p>
<p>$$(k,c_1)\leftarrow Encap_{\mathfrak{pk}}()$$</p>
<p>$$c_2\leftarrow e_k(m)$$</p>
<p>$$c\leftarrow (c_1,c_2)$$</p>
<p>Upon receiving $c$ the recipient performs</p>
<p>$$k\leftarrow Decap_{\mathfrak{sk}}(c_1)$$</p>
<p>$$\text{If } k=\bot \text{ return }\bot$$</p>
<p>$$m\leftarrow d_k(c_2)$$</p>
<p>$$\text{return }m$$</p>
<h4 id="rsa-kem">RSA-KEM</h4>
<p>Let $N$ be RSA modulus, product of two primes $p$ and $q$, and function $f$ is RSA encryption, then encapsulation will be</p>
<p>$$x\leftarrow \{1,&hellip;,N-1\}$$</p>
<p>$$c\leftarrow f_{N,e}(x)$$</p>
<p>$$k\leftarrow H(x)$$</p>
<p>$$\text{Output }(k,c)$$</p>
<p>Decapsulation will be</p>
<p>$$x\leftarrow f_N^{-1}(c)$$</p>
<p>$$k\leftarrow H(x)$$</p>
<p>$$\text{Output }k$$</p>
<p>RSA-KEM <strong>is IND-CCA</strong> secure under ROM (Random Oracle Mode).</p>
<h4 id="dhies-kem">DHIES-KEM</h4>
<p>Diffie-Hellman Integrated Encryption Scheme uses a cyclic finite abelian group $G$ of prime order $q$ for key generation, as well as a key generator $g$, Key space $K$, key derivation function $H$, generate $x$ in $\mathbb{Z}_N$, and compute $h=g^x$.</p>
<p>Encapsulation and decapsulation are then given as</p>
<p><img src="/images/IN4191/DHIES-KEM.png" alt="DHIES-KEM"></p>
<p>This <strong>is IND-CCA</strong> secure if the hash function is secure.</p>
<h3 id="secure-signature-schemes">Secure Signature Schemes</h3>
<h4 id="rsa-fdh">RSA-FDH</h4>
<p>RSA-Full Domain Hash is a combination of RSA and hash functions for an efficient and secure signature scheme. It works by taking the hash of the message and signing it with the private key and upon receiving the signature is verified by using the public key and the calculated hash of the message, and comparing the two hashes. This scheme is secure but the codomain of the hash function needs to match the domain of RSA.</p>
<h4 id="rsa-pss">RSA-PSS</h4>
<p>RSA-Probabilistic Signature Scheme has $N$ as a RSA modulo of size $k$ bits with $e$ and $d$, and two parameters $k_0$ and $k_1$ such that $k_0+k_1&lt;k-1$ with the following hash functions</p>
<p>$$G: \{0,1\}^{k_1}\rightarrow \{0,1\}^{k-k_1-1}$$</p>
<p>$$H: \{0,1\}^*\rightarrow \{0,1\}^{k_1}$$</p>
<p>and</p>
<p>$$G_1: \{0,1\}^{k_1}\rightarrow \{0,1\}^{k_0}$$</p>
<p>$$G_2: \{0,1\}^{k_1}\rightarrow \{0,1\}^{k-k_0-1}$$</p>
<p>$$G(w)=g_1(w)||G_2(w)$$</p>
<p><img src="/images/IN4191/RSA-PSS.png" alt="RSA-PSS"></p>
<h4 id="dsa">DSA</h4>
<p>Digital Signature Algorithm exists because</p>
<ul>
<li>RSA based schemes are costly in terms of signature generation</li>
<li>RSA based signatures are large</li>
<li>RSA might be broken soon</li>
</ul>
<p>Digital signature algorithm is based on finite fields or elliptic curves.</p>
<p>It uses a large prime $p$ such that $p-1$ is divisible by another prime $q$, a generator $g$ of the finite field in mod $p$ with an order $q$, and a hash function that maps bit strings to $\mathbb{Z}_p$.</p>
<p>The secret key will be an integer $x$ in $[0,&hellip;,q-1]$ and the public key as $h=g^x$.</p>
<p><img src="/images/IN4191/DSA.png" alt="DSA"></p>
<h4 id="ec-dsa">EC-DSA</h4>
<p>Elliptic curve version of DSA, choose a random integer $a$ and a point $P$, where $a$ is the secret key, and compute the public key $Q=aP$</p>
<p><img src="/images/IN4191/EC-DSA.png" alt="EC-DSA"></p>
<p>Smaller key size due to elliptic curves and no exponentiations but point operations on the elliptic curve.</p>
<h4 id="schorr-signatures">Schorr Signatures</h4>
<p>$G$ is a public abelian group with generator $g$ of prime order $q$ with private key $x$ in $[0,&hellip;,q-1]$ and public key $h=g^x$.</p>
<p>Signing a message is done as</p>
<p>$$k\leftarrow \mathbb{Z}_q$$</p>
<p>$$r\leftarrow g^k$$</p>
<p>$$e\leftarrow H(m||r)$$</p>
<p>$$s\leftarrow k+x*e\text{ mod }q$$</p>
<p>Verification is done as</p>
<p>$$r\leftarrow g^s*h^{-e}$$</p>
<p>The signature is only valid if and only if $e=H(m||r)$.</p>
<h4 id="nyberg-rueppel-signature">Nyberg-Rueppel Signature</h4>
<p>If the message is small we can verify the signature and extract the message from it. This is a log based scheme with message recovery, but it requires redundancy (e.g. doubling the message by concatenating it twice $m||m$) which is easy to revert.</p>
<p>$G$ is a public abelian group with generator $g$ of prime order $q$ and private key $x=[0,&hellip;,q-1]$ and public key $h=g^x$.</p>
<p><img src="/images/IN4191/Nyberg-Ruppel.png" alt="Nyber-Ruppel"></p>
]]></content></item><item><title>Lecture 9: The RSA Algorithm</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-9/</link><pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate><guid>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-9/</guid><description>The RSA Algorithm (Chapter 15) The RSA algorithm is based on the difficulty of the RSA problem that it is difficult to to find $d$ given a large composite number $N$ and $e$. It works by taking two large secret prime numbers $p$ and $q$ and computing $N=p*q$. Then picking an encryption exponent $e$ that satisfies
$$\text{gcd}(e,(p-1)*(q-1))=1$$
It is common to chose values $e=3,17,65537$. Now the public key will be shared as the pair of $\mathfrak{pC}=(N,e)$.</description><content type="html"><![CDATA[<h2 id="the-rsa-algorithm-chapter-15">The RSA Algorithm (Chapter 15)</h2>
<p>The RSA algorithm is based on the difficulty of the RSA problem that it is difficult to to find $d$ given a large composite number $N$ and $e$. It works by taking two large secret prime numbers $p$ and $q$ and computing $N=p*q$. Then picking an encryption exponent $e$ that satisfies</p>
<p>$$\text{gcd}(e,(p-1)*(q-1))=1$$</p>
<p>It is common to chose values $e=3,17,65537$. Now the public key will be shared as the pair of $\mathfrak{pC}=(N,e)$. The private key is computed by applying the extended euclidean algorithm on $e$ and $(p-1)(q-1)$ to obtain the decryption exponent $d$ that satisfies</p>
<p>$$e*d=1\text{ mod }(p-1)(q-1)$$</p>
<p>The secret key can be kept as just $\mathfrak{sK}=(d)$ or $\mathfrak{sK}=(d,p,b)$</p>
<p><strong>Encryption</strong> can then simply be done by</p>
<p>$$c\leftarrow m^e\text{ mod }N$$</p>
<p>and <strong>decryption</strong> is done as</p>
<p>$$m\leftarrow c^d\text{ mod }N$$</p>
<p><img src="/images/IN4191/RSA-Proof.png" alt="RSA Correctness"></p>
<h3 id="security-of-rsa">Security of RSA</h3>
<p>Computing $d$ given $e$ and $N$ is no harder than factoring $N$, so if you can factor $N$ you can compute $d$.</p>
<p>The current suggestion for medium term security is to use a modulo of 2048 bits.</p>
<p>RSA <strong>is OW-CPA</strong> secure, but <strong>not IND-CPA</strong> secure since the system is deterministic.</p>
<p>Additionally RSA is malleable due to <strong>homomorphism</strong>, stating that an encryption scheme has the (multiplicative) homomorphic property if given the encryptions of $m_1$ and $m_2$ we can determine the encryption of $m_1*m_2$ without knowing $m_1$ or $m_2$.</p>
<p>$$(m_1<em>m_2)^e\text{ mod }N=((m_1\text{}^e\text{ mod }N)</em>(m_2\text{}^e\text{ mod }N)) \text{ mod }N$$</p>
<p>RSA is <strong>not OW-CCA</strong> secure. This is proven by multiplying the challenger&rsquo;s ciphertext by two and having the oracle decrypt it. The oracle checks if the ciphertext is the original ciphertext, which it is not and will decrypt. But since you know the relationship to the original ciphertext, you can just divide the decrypted plaintext by 2 and retrieve the original message.</p>
<h3 id="rabin-encryption">Rabin Encryption</h3>
<p>Choose $p$ and $q$ such that $p=q=3\text{ mod }4$ and then use private key $\mathfrak{sK}=(p,q)$ and public key $\mathfrak{pK}=(N)$.</p>
<p>Encryption is done by computing $c\leftarrow m^2 \text{ mod } N$ and decryption as</p>
<p>$$m_p=\sqrt{c}\text{ mod }p=c^{(p+1)/4}\text{ mod }p$$</p>
<p>$$m_q=\sqrt{c}\text{ mod }q=c^{(q+1)/4}\text{ mod }q$$</p>
<p>followed by applying the Chinese Remainder Theorem to combine $m_p$ and $m_q$.</p>
<p><strong>Is OW-CPA</strong> secure based on the factoring problem but the mapping is not injective, meaning that encryption produces one ciphertext but decryption produces 4 possible plaintexts.</p>
<p><strong>Not OW-CCA</strong> secure and <strong>not IND-CPA</strong> secure.</p>
<h3 id="the-naive-rsa-signature">The &ldquo;Naive&rdquo; RSA Signature</h3>
<p>Construct $d$ the same way as was done in RSA before, now senders sign a message by decrypting it and the receiver verifies the signature by encryption and obtains the message</p>
<p>$$\text{Signing: }s\leftarrow m^d\text{ mod }N$$</p>
<p>$$\text{Verification: }m\leftarrow s^e\text{ mod }N$$</p>
<h4 id="checking-validity-of-signatures">Checking Validity of Signatures</h4>
<p>We need to check the validity of signatures, which means that padding is required. Padding in RSA works with message $m$ is $t$ bits, and $N$ is $k$ bits with $t&lt;k-32$ bits. Pad $m$ with zeros on the left to make it a multiple of 8 bits and add $(k-t)/8$ bytes to the left of $m$ such that</p>
<p>$$m\leftarrow 00||01||FF||FF &hellip;||FF||00||m$$</p>
<p>This way of padding prevents trivial selective forgery.</p>
<h4 id="selective-forgery">Selective Forgery</h4>
<p>If there is a signing oracle and the attacker wants to obtain a signature $s$ of $m$, he generates a random message $m_1\in \mathbb{Z}_N^*$ such that</p>
<p>$$m_2 \leftarrow \frac{m}{m_1}$$</p>
<p>then asking the oracle to sign $m_1$ and $m_2$ and getting the individual signatures to construct the original one</p>
<p>$$s_i=m_i^d\text{ mod } N$$</p>
<p>$$s\leftarrow s_1*s_2\text{ mod }N$$</p>
<p>since</p>
<p>$$s=s_1*s_2\text{ mod }N$$</p>
<p>$$=m_1^d*m_2^d\text{ mod }N$$</p>
<p>$$=(m_1*m_2)^d\text{ mod }N$$</p>
<p>$$=m^d\text{ mod } N$$</p>
<p>Hence, by applying this kind of padding the homomorphism is destroyed.</p>
<h4 id="signing-documents">Signing Documents</h4>
<p>Divide the message $m$ into blocks, serial numbers and redundancy is needed, but signing data one by one is very inefficient, since RSA decryption is very slow due to the large value of $d$.</p>
<p>To solve it we do not want to sign every block, but hash the message and sign the hash but send the signed hash as a pair with the message, and the receiver will calculate the hash of the message and compare that to the received hash.</p>
<p><img src="/images/IN4191/RSA-Sign_Docs.png" alt="RSA Signing Documents"></p>
<p>For this system to be secure, the hash function needs to be secure (preimage-, second preimage-, and collision- resistance).</p>
<h4 id="more-security-of-rsa">More Security of RSA</h4>
<p><strong>Knowing $\phi(N)$ and $N$</strong> one can find $p$ and $q$, since $\phi(N)=(p-1)(q-1)=p*q-p-q+1=N-p-q-1$, and $S=N+1+\phi$, and $S=p+q$, then we have</p>
<p>$$f(X)=(X-p)(X-q)=X^2-S*X+N$$</p>
<p>$$p=\frac{S+\sqrt{S^2-4*N}}{2}$$</p>
<p>$$q=\frac{S-\sqrt{S^2-4*N}}{2}$$</p>
<p><strong>Using a shared modulus</strong> (using the same $p$ and $q$), the attacker can trivially calculate $d$. In the first case, bob and the attacker are sharing a modulus (and bob is index 2), the attacker can calculate $d$ using $e_2*d_2\equiv 1\text{ mod }\phi(N)$.</p>
<p>In the second case, if the attacker can obtain two different ciphertexts for the same plaintext by both other parties, he can find the keys</p>
<p><img src="/images/IN4191/RSA-Shared-Modulus.png" alt="Shared Modulus"></p>
<p><strong>Using a small public exponent</strong>, suppose there are three parties and they all use the same small public exponent, then</p>
<p><img src="/images/IN4191/RSA-Small_EXP.png" alt="Small exponent"></p>
<p><strong>Wiener&rsquo;s Attack</strong> If one wants to speedup the performance by choosing a smaller value for the private exponent $d$, this will lead to a large value of the encryption exponent $e$ and we cannot choose too small a value for $d$, otherwise an attacker could find $d$ using exhaustive search. But it turns out that $d$ needs to be at least the size of $\frac{1}{3}*N^{1/4}$, otherwise one could attack using Wiener&rsquo;s attack.</p>
<p>The attack uses continued fractions to give a linear time algorithm to determine the private exponent when it is less than $\frac{1}{3}*N^{1/4}$.</p>
<h4 id="fault-analysis">Fault Analysis</h4>
<p>Fault analysis is the introduction of faults into a system and tricking it into doing some calculation incorrectly, by for example altering the environment, heating or cooling the chip, or by damaging the circuit in some way.</p>
]]></content></item><item><title>Lecture 8: Number Theory and Elliptic Curves</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-8/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-8/</guid><description>Number Theory and Elliptic Curves (Chapter 1 &amp;amp; 4) Modular Arithmetic A positive integer $N$ called modulus is written as
$$a=b\text{ mod }N$$
if $N$ divides $b-a$, $a$ and $b$ are congruent modulo $N$.
The set of values produced by postfix operation mod $N$ is $\mathbb{Z}_N=\{0,1,&amp;hellip;,N-1\}$ (can also be written as $\mathbb{Z}/N\mathbb{Z}$).
The properties of modulo arithmetic are
A group is a set which is closed, has an identity, is associative, and every element has an inverse.</description><content type="html"><![CDATA[<h2 id="number-theory-and-elliptic-curves-chapter-1--4">Number Theory and Elliptic Curves (Chapter 1 &amp; 4)</h2>
<h3 id="modular-arithmetic">Modular Arithmetic</h3>
<p>A positive integer $N$ called modulus is written as</p>
<p>$$a=b\text{ mod }N$$</p>
<p>if $N$ divides $b-a$, $a$ and $b$ are congruent modulo $N$.</p>
<p>The set of values produced by postfix operation mod $N$ is $\mathbb{Z}_N=\{0,1,&hellip;,N-1\}$ (can also be written as $\mathbb{Z}/N\mathbb{Z}$).</p>
<p>The properties of modulo arithmetic are</p>
<p><img src="/images/IN4191/Mod-properties.png" alt="Modulo Arithmetic properties"></p>
<p>A group is a set which is closed, has an identity, is associative, and every element has an inverse. A group that is commutative is called <strong>abelian</strong>.</p>
<p>Properties 1,2,3,4 are <strong>Groups</strong>.
Properties 1,2,3,4,5 are <strong>Abelian Groups</strong>.</p>
<p>Group types:</p>
<ul>
<li><strong>multiplicative group</strong> group operation is multiplication to create the group
<ul>
<li>$(G,x):f=g*h \text{ and } g^5=g*g*g*g*g$</li>
</ul>
</li>
<li><strong>additive group</strong> group operation is addition
<ul>
<li>$f=g+h \text{ and } 5*g=g+g+g+g+g$</li>
</ul>
</li>
<li><strong>cyclic abelian group</strong> if there is a special element (generator) from which every other element in the group can be obtained by applying the group operation.</li>
</ul>
<p>Rings:</p>
<p>A ring has two operations (+,*) with properties 1 to 9, and is denotes as (R,+,*). If multiplication is commutative (property 10), then the ring is commutative.</p>
<h4 id="eulers-totient-function">Euler&rsquo;s Totient Function</h4>
<p>Euler&rsquo;s totient function counts how many coprimes there  are for a given in its set $\mathbb{Z}_N$.
For equations $a*x=b\text{ mod }N$ finding the solution,</p>
<p>$$7*x=3\text{ mod } 143\text{ has one solution}$$</p>
<p>$$11*x=3\text{ mod } 143\text{ has no solution}$$</p>
<p>$$7*x=22\text{ mod } 143\text{ has 11 solution}$$</p>
<p>finding the number of solutions is done by computing the gcd of $a$ and $N$ and has the cases:</p>
<ol>
<li>if $\text{gcd}(a,N)=1$, there is exactly one solution</li>
<li>if $\text{gcd}(a,N)=g\ne1 \text{ and gcd}(a,N)\text{ divides }b, \text{ there are }g \text{ solutions}$</li>
<li>otherwise there is no solution</li>
</ol>
<p>The case where the $\text{gcd}(a,N)=1$ $a$ and $N$ are called relatively prime or coprime.</p>
<p>The number of integers in $\mathbb{Z}_N$ is given by Euler&rsquo;s Totient function</p>
<p>$$\phi(N)=\prod_{i=1}^np_i^{e_i-1}(p_i-1)$$</p>
<p>where</p>
<p>$$N=\prod_{i=1}^np_i^{e_i}$$</p>
<p>With this the totient function will tell us how many coprimes there are in the set of $\mathbb{Z}_N$ and we can then calculate all the coprimes in the set as</p>
<p>$$\mathbb{Z}_N^*=\{1\le a &lt; n | \text{ gcd}(a,n)=1\}$$</p>
<p>If $p$ is a prime, then $\phi(p)=p-1$.<br>
If $p$ and $q$ are both prime, then $\phi(p*q)=(p-1)(q-1)$.</p>
<p>For example $\phi(15)$ is not prime but using</p>
<p>$$N=p*q$$</p>
<p>$$15=3*5$$</p>
<p>we can calculate</p>
<p>$$\phi(15)=(3-1)(5-1)=8$$.</p>
<h4 id="multiplicative-inverse-modulo">Multiplicative Inverse Modulo</h4>
<p>Finding a $c$ such that</p>
<p>$$a<em>c=c</em>a=1\text{ mod } N$$</p>
<p>such a $c$ is called the multiplicative inverse modulo $N$ of $a$: $a^{-1}$, and only exists when $a$ and the module $N$ are coprime, $gcd(a,N=1)$.</p>
<p>If $p$ is a prime, then all non-zero elements have a multiplicative inverse in $\mathbb{Z}_N$, thus $a*x=b \text{ mod } b$ has a unique solution. A ring with all non-zero elements having a multiplicative inverse is called a field.</p>
<p>A field is a set with two operations $(G,*,+)$ such that</p>
<ul>
<li>$(G,+)$ is an abelian group</li>
<li>$(G/0,x)$ is an abelian group</li>
<li>$(G,*,+)$ satisfies the distributive law</li>
</ul>
<p>The size of $\mathbb{Z}_N$ is given by $\phi(N)$ and if $N$ is a prime, $\mathbb{Z}_N^*=\{1,&hellip;,p-1\}$</p>
<p><strong>Lagrange&rsquo;s theorem</strong> states that if $(G,*)$ is a group of order (size) $n=\text{ sizeof }G$ (order is calculated with the totient function), then for all $a$ in $G$ we have $a^n=1$ (every single item in $\mathbb{Z}_N$ to the power of the order).</p>
<p><strong>Fermat&rsquo;s Little theorem</strong> states that if $p$ is a prime and $a$ is in $Z$, them $a^p=a\text{ mod } p$.</p>
<h4 id="basic-algorithms">Basic Algorithms</h4>
<p><strong>Euclidean Algorithm</strong> is for computing of $\text{gcd}(a,b)$ and $a=qb+r$.
We can reduce with $\text{gcd}(a,b)=\text{gcd}(a\text{ mod } b,b)$ until we reach $gcd(0,x)$ where $x$ is the $\text{gcd}$</p>
<p><img src="/images/IN4191/Euclidean-example.png" alt="Euclidean Algorithm Example"></p>
<p><strong>Extended Euclidean Algorithm</strong> states that any number $\text{gcd}(a,b)=r$ can be written in the form of $ax+by=r$, hence for a $\text{gcd}(a,N)=d$ where $d=1$ we can compute $ax+yN=1$, where $x$ is the multiplicative inverse of $a$ in modulo $N$.</p>
<p><strong>Chinese Remainder Theorem</strong> states that if we have two equations $x=a\text{ mod } N\text{ and }x=b\text{ mod }M$ then there is a unique solution modulo $M*N$ if and only if $\text{gcd}(N,M)=1$, and is given as</p>
<p>$$x\leftarrow \sum_{i=1}^ra_i*M_i*y_i\text{ mod } M$$</p>
<p>where</p>
<p>$$M_i\leftarrow M/m_i \text{ and } y_i\leftarrow M_i^{-1} \text{ mod }m_i$$</p>
<h4 id="legendre-symbol">Legendre Symbol</h4>
<p>Used to make it easier to detect squares modulo a prime $p$. The set of squares in $\mathbb{F}_P^*$ is called the <em>quadratic residue</em> and is of the size $(p-1)/2$, all elements not in the quadratic residue are called <em>non-quadratic residue</em>. Legendre symbols are defines as</p>
<p>$$(\frac{a}{p})=a^{(p-1)/2}\text{ mod }p$$</p>
<p>which is</p>
<ul>
<li>0 if $p$ divides $a$</li>
<li>1 if $a$ is a quadratic residue</li>
<li>-1 if $a$ is a non-quadratic residue</li>
</ul>
<p>Legendre symbols are computed as</p>
<p>$$(\frac{q}{p})=(\frac{p}{q})(-1)^{(p-1)(q-1)/4}$$</p>
<p>which means</p>
<p><img src="/images/IN4191/legendre_form.png" alt="Legendre Formula"></p>
<p>and we have additional formulae</p>
<p><img src="/images/IN4191/legendre_formulae.png" alt="Legendre Formulae"></p>
<h4 id="jacobi-symbol">Jacobi Symbol</h4>
<p>Legendre symbols are defined if the denominator is prime, but for composite denominators we use Jacobi symbols, which are given as</p>
<p>$$(\frac{a}{n})=(\frac{a}{p_1})^{e_1}(\frac{a}{p_2})^{e_2}&hellip;(\frac{a}{p_k})^{e_k}$$</p>
<p>where</p>
<p>$$n=p_1^{e_1}*p_2^{e_2}&hellip;p_k^{e_k}$$</p>
<p>If $a$ is a square, the jacobi symbol will be 1, however if the jacobi symbol is 1, $a$ might not be a square.</p>
<h4 id="fermats-test">Fermat&rsquo;s Test</h4>
<p>It states that using Euler&rsquo;s totient function</p>
<p>$$a^{\phi(n)}=1\text{ mod }n$$</p>
<p>If $n$ is a prime this equality holds, however if this equality holds not necessarily is $n$ a prime.</p>
<p><img src="/images/IN4191/Fermats-test.png" alt="Fermat&rsquo;s Test"></p>
<h4 id="miller-rabin-test">Miller-Rabin Test</h4>
<p>Because of Carmichael numbers Fermat&rsquo;s test is not useful (they always return &ldquo;probably prime&rdquo;). The Miller-Rabin test is an improved version with a chance of $1/4$ for a base $a$.</p>
<p><img src="/images/IN4191/Miller-rabin.png" alt="Miller-Rabin Test"></p>
<h3 id="elliptic-curves">Elliptic Curves</h3>
<p>Elliptic curves are used in modern cryptography as a way of improving efficiency and bandwidth, defined as</p>
<p>$$F: y^2=x^3+ax+b\text{ mod }p$$</p>
<p>with requirements:</p>
<ul>
<li>$p&gt;3$, otherwise $x^3=x$ (Fermat)</li>
<li>$4a^3 +27b^2\ne 0\text{ mod }p$, otherwise $F$ is singular</li>
<li>If $P$ is on $F$, then also $P+P$, $P+P+P$ etc..</li>
</ul>
<p><img src="/images/IN4191/EC-Point-Addition.png" alt="Point Addition"></p>
<p>The zero point is given for</p>
<p>$$F:y^2=x^3+ax+b\text{ mod }p$$</p>
<p>with the following properties</p>
<ul>
<li>$P+(-P)=0$</li>
<li>$Q+(-Q)=0$</li>
<li>$P+0=0+P=P$</li>
</ul>
<p>Total number of points on the curve will be $p$ (whatever modulo there is) and the zero point will be the last point $NP$ out of all points ($P,1P,2P,&hellip;,NP)$. It is also called the identity element, and after it elements will start repeating (e.g. in $\text{mod }11$ point $12P$ is the same $P$)</p>
<h4 id="addition-rules">Addition Rules</h4>
<p>We are adding two points $P=(x_1,y_1)$ and $Q=(x_2,y_2)$, then re result is $R=(x_3,y_3)$</p>
<ul>
<li>
<p>If $x_1=x_2$ and $y_1=-y_2$, then $(x_3,y_3)=0$ (special point at infinity)</p>
</li>
<li>
<p>else</p>
<p>$$x_3=\lambda^2-x_1-x_2\text{ mod }p$$</p>
<p>$$y_3=\lambda(x_1-x_3)-y_1\text{ mod }p$$</p>
<p>where</p>
<p>$$\lambda=(y_2-y_1)/(x_2-x_1)\text{ mod }p \text{ If }P\ne Q$$</p>
<p>$$\lambda=(3x_1^2+a)/(2y_1)\text{ mod }p\text{ If }P=Q$$</p>
</li>
</ul>
<h4 id="elliptic-curve-discrete-log-problem">Elliptic Curve Discrete Log Problem</h4>
<p>The problem states that for a positive integer $m$ and a point $P$, it is easy to compute $Q=mP$, but given $Q$ and $P$ it is difficult to compute $m$.</p>
<p>For elliptic curves the prime number $p$ can be smaller (e.g. 128 bits) to make it infeasible, as opposed to making the calculation infeasible for DLP based systems (e.g. primer number $\ge1024$ bits). Equivalently hard problems but much smaller values, hence brining much better performance.</p>
]]></content></item><item><title>Lecture 7: Hash Functions, MAC, and Key Derivation Functions</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-7/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-7/</guid><description>Hash Functions, MAC, and Key Derivation Functions (Chapter 14) Hash functions are used for integrity protection (checksum, file system integrity like Bit-torrent), one way encryption (password protection), asymmetric crypto schemes, MACs, key derivations, pseudo random number generators, and many more applications.
Hash functions receive an arbitrary length bit string and output a fixed length string called the hash value, digest, fingerprint, or hashcode. Hash functions are one way: easy to compute $y$ given $x$, where $y: H: \{0-1\}*\rightarrow\{0-1\}^n$</description><content type="html"><![CDATA[<h2 id="hash-functions-mac-and-key-derivation-functions-chapter-14">Hash Functions, MAC, and Key Derivation Functions (Chapter 14)</h2>
<p>Hash functions are used for integrity protection (checksum, file system integrity like Bit-torrent), one way encryption (password protection), asymmetric crypto schemes, MACs, key derivations, pseudo random number generators, and many more applications.</p>
<p>Hash functions receive an arbitrary length bit string and output a fixed length string called the hash value, digest, fingerprint, or hashcode.
Hash functions are one way: easy to compute $y$ given $x$, where $y: H: \{0-1\}*\rightarrow\{0-1\}^n$</p>
<p>$$H(x)=y$$</p>
<p>and $x$ is called the preimage.</p>
<p>Need to have three properties:</p>
<ol>
<li><strong>Preimage Resistance:</strong> given a hash value $y$, it should be infeasible to find $x$.</li>
<li><strong>Second Preimage Resistance:</strong> given a preimage $x$, it should be hard to find an $x'$ with the same hash such that $y=y'$. This is done by making the output space large enough (i.e. $2^{128}$), since $2^n$ attempts are required.</li>
<li><strong>Collision Resistance:</strong> given two preimages $x$ and $x'$ it should be infeasible to compute the same hash $y$. The difference to second preimage resistance is that here we are not looking for a single pair of preimages that give the same hash, but any pair (remember all your previous hash calculations).</li>
</ol>
<p>As there is guaranteed to exist an adversary that can break collision resistance, since we know a larger input domain will have to map multiple inputs to the same output if the output domain is fixed (pigenhole principle applies), but given human ignorance we can assume hash functions to be collision resistant. Human ignorance states that in the same domain the collision will likely be a meaningless preimage. For example trying to find the collision of a hashed contract will just be random bits.</p>
<p>Definition: A function is said to be collision resistant (by human ignorance) or HI-CR secure if it is believed to be infeasible to write down a collision for the function, i.e. two elements in the domain mapping to the same element in the codomain.</p>
<p>Terminology:</p>
<ul>
<li><strong>one way:</strong> preimage + second preimage resistant
<ul>
<li>sometimes only preimage resistant</li>
</ul>
</li>
<li><strong>weak collision resistant:</strong> second preimage resistant</li>
<li><strong>strong collision resistant:</strong> collision resistant</li>
<li><strong>OWHF (One way hash function):</strong> preimage and second preimage resistant</li>
<li><strong>CRHF (collision resistant hash function):</strong> second preimage and collision resistant</li>
</ul>
<h3 id="padding">Padding</h3>
<p>The input to a compression function needs to be a multiple of the block size, which requires to add padding bits such that</p>
<p>$$m||pad_i(|m|,b)$$</p>
<p>There are 5 main padding methods of which method 0 is not secure.</p>
<ol>
<li><strong>Method 0:</strong> Let $v$ denote $b−|m|(\text{ mod } b)$. Add $v$ zeros to the end of the message $|m|$, i.e. $m‖pad_0(|m|,b)=m‖0∗$.</li>
<li><strong>Method 1:</strong> Let $v$ denote $b−(|m|+1) (\text{ mod }b)$. Append a single 1 bit to the message, and then pad with $v$ zeros, i.e. $m‖pad_1(|m|,b)=m‖10∗$.</li>
<li><strong>Method 2:</strong> Let $v$ denote $b−(|m|+ 65) (\text{ mod }b)$. Encode $|m|$ as a 64-bit integer $l$. Append a single 1 bit to the message, and then pad with $v$ zeros, and then append the 64-bit integer $l$, i.e. $m‖pad_2(|m|,b)=m‖10∗‖l$.</li>
<li><strong>Method 3:</strong> Let $v$ denote $b−(|m|+ 64) (\text{ mod } b)$. Encode $|m|$ as a 64-bit integer $l$.Pad with $v$ zeros, and then append the 64-bit integer $l$, i.e. $m‖pad_3(|m|,b)=m‖0∗‖l$.</li>
<li><strong>Method 4:</strong> Let $v$ denote $b−(|m|+2) (\text{ mod }b)$. Append a single 1 bit to the message, and then pad with $v$ zeros, and then add a one-bit, i.e. $m‖pad_4(|m|,b)=m‖10∗1$.</li>
</ol>
<h3 id="merkle-damgard-construction">Merkle-Damgard Construction</h3>
<p><strong>Compression function:</strong> A hash function that receives a fixed length input.</p>
<p><img src="/images/IN4191/MD.png" alt="MD"></p>
<p>Its construction is based on a family of compression functions $f_k$ that map $(l+n)$ bit inputs to $n$ bit outputs.</p>
<p><img src="/images/IN4191/MD_Alg.png" alt="MD Algorithm"></p>
<p>Conventionally MD algorithms use padding method 2.</p>
<h3 id="md-4-family">MD-4 Family</h3>
<p>The main algorithms in the MD-4 family, which are based on the MD construction are:</p>
<ul>
<li><strong>MD-4:</strong> The function $f$ has 3 rounds of 16 steps and an output bit length of 128 bits.</li>
<li><strong>MD-5:</strong> The function $f$ has 4 rounds of 16 steps and an output bit length of 128 bits.</li>
<li><strong>SHA-1:</strong> The function $f$ has 4 rounds of 20 steps and an output bit length of 160 bits.</li>
<li><strong>RIPEMD-160:</strong> The function $f$ has 5 rounds of 16 steps and an output bit length of 160 bits.</li>
<li><strong>SHA-2:</strong>
<ul>
<li><strong>SHA-256:</strong> The function $f$ has 64 rounds of single steps and an output bit length of 256 bits.</li>
<li><strong>SHA-384:</strong> The function $f$ is identical to SHA-512 except the output is truncated to 384 bits, and the initial chaining valueHis different.</li>
<li><strong>SHA-512:</strong> The function $f$ has 80 rounds of single steps and an output bit length of 512 bits.</li>
</ul>
</li>
</ul>
<p>Due to birthdaying, the collision space to find a collision in MD-4 becomes $2^{1/2n}$</p>
<h4 id="birthdaying-paradox">Birthdaying Paradox</h4>
<p>Given a set of $t$ $(\ge 10)$ elements, take a sample of size $k$ (drawn with repetition) in oder to get probability $\ge 1/2$ on a collision (i.e. an element drawn at least twice). $k$ has to be $\ge 1.2 \sqrt{t}$</p>
<p>Therefore if $F:A\rightarrow B$ (function $F$ is a mapping from $A$ to $B$) is a random function and $\text{sizeof }A&raquo;\text{sizeof }B$ (size of $A$ is huge compared to $B$) then one can expect a collision after about $\sqrt{(\text{sizeof }B)}$ random function calls.</p>
<h3 id="hmac">HMAC</h3>
<p>Have a keyed hash from an unkeyed hash function. Trivially this can be done by concatenating the message with the key and then hashing all of it</p>
<p>$$t=H(k||m||pad_i(|k|+|m|,b))$$</p>
<p>but this is not safe as the adversary can construct new valid hashes based on the previous hashes, without knowing the key.</p>
<p>Used a nested MAC (<strong>NMAC</strong>), that is built from two keyed hashes</p>
<p>$$\text{NMAC}<em>{k1,k2}(m)=F</em>{k_1}(G_{k_2}(m))$$</p>
<p>$$F_{k_1}(x)=f((x||pad_2(l+|x|,l))||k_1)=\text{MD}[f,k_1]^*(x)$$</p>
<p>$$G_{k_2}(m)=\text{MD}[f,k_2]^*(m)$$</p>
<p>then we have</p>
<p>$$\text{NMAC}_{k_1,k_2}(m)=\text{MD}[f,k_1]<em>(\text{MD}[f,k_2]^</em>(m))$$</p>
<p>We can then construct the function HMAC using NMAC as follows</p>
<p>$$\displaylines{\text{HMAC}_k(m)=H((k\oplus opad)||H((k\oplus ipad)||m))\<br>
=\text{MD}[f,IV]((k\oplus opad)||\text{MD}[f,IV]((k\oplus ipad)||m))}$$</p>
<p>with $opad$ and $ipad$ being fixed $l$ bit padding values.</p>
<h4 id="mac-from-a-block-cipher">MAC from a Block Cipher</h4>
<p>We can use a cipher block chaining mode on MAC in the following way</p>
<p><img src="/images/IN4191/CBC-MAC.png" alt="CBC MAC"></p>
<p>With this we can then double encrypt with a second key as follows</p>
<p>$$\text{EMAC}<em>{k_1,k_2}(m)=e</em>{k_2}(CBC-MAC_{k_1}(m))$$</p>
<h3 id="sponge-construction">Sponge Construction</h3>
<p>The construction absorbs the message and when output is required it is squeezed from the construction. The permutation function is a fixed function (not one way).</p>
<p><img src="/images/IN4191/Sponge.png" alt="Sponge Construction"></p>
<p>Using this sponge construction <strong>IND-CCA secure</strong> encryption and decryption can also be done, or sponge based MACs and sponge based stream ciphers.</p>
<p><img src="/images/IN4191/IND-CCA-Sponge.png" alt="IND-CCA Secure Sponge"></p>
]]></content></item><item><title>Lecture 6: Block Ciphers and Modes of Operation</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-6/</link><pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate><guid>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-6/</guid><description>Block Ciphers and Modes of Operation (Chapter 13) Block ciphers operate on blocks of plaintext at a time to produce blocks of ciphertext. Block sizes tend to be large, 64 bits in DES and 128 bits in other modern block ciphers. In order to limit the advantage of the adversary, the key space is kept very large such that $Adv_{{F_k}K}^{PRP}(A)\approx 1/|K|$. Block cipher is part of an encryption but requires a mode of operation, these are both developed independently.</description><content type="html"><![CDATA[<h4 id="block-ciphers-and-modes-of-operation-chapter-13">Block Ciphers and Modes of Operation (Chapter 13)</h4>
<p>Block ciphers operate on blocks of plaintext at a time to produce blocks of ciphertext. Block sizes tend to be large, 64 bits in DES and 128 bits in other modern block ciphers. In order to limit the advantage of the adversary, the key space is kept very large such that $Adv_{{F_k}K}^{PRP}(A)\approx 1/|K|$.
Block cipher is part of an encryption but requires a mode of operation, these are both developed independently.</p>
<p>DES (Data Encryption Standard) was an <em>iterated</em> block cipher which uses a <em>round function</em> repeatedly. DES was deemed unsafe in the 90s but other variants (3DES, shown below) are still being used. Another such cipher is AES (Advanced Encryption Standard). The round function takes a block and returns a block of the same size, and the number of rounds can be fixed or varied. Each use of the round function uses a round key derived from the main secret key using an algorithm called <em>key scheduling</em>. The round function should be invertible for decryption and using round keys in reverse order.</p>
<p><img src="/images/IN4191/3DES.png" alt="3DES"></p>
<p>In DES the round is invertible but not the round function.</p>
<p>In AES both the round and the round function are invertible.</p>
<p>Techniques (+Luck) for breaking block ciphers:</p>
<ul>
<li><strong>Differential Cryptanalysis:</strong> looking at the ciphertext pairs where the plaintexts have certain differences. For breaking DES it requires $2^{37}$ in time and $2^{47}$ in memory.</li>
<li><strong>Linear Cryptanalysis:</strong> approximate the behavior of non-linear components of the block cipher with linear functions. For breaking DES it requires $2^{43}$ plaintexts.</li>
</ul>
<p>Shannon&rsquo;s confusion-diffusion paradigm</p>
<ul>
<li><strong>Confusion:</strong> Split the block into smaller blocks and apply a permutation on each block</li>
<li><strong>Diffusion:</strong> Mix permutations so that local change can effect the whole block</li>
</ul>
<p><strong>Substitution-permutation networks</strong> are a direct implementation of Shannon&rsquo;s paradigm by mixing keys, substituting, and permutation.</p>
<p><em>Avalanche effect</em> states that a single change in the plaintext must affect every bit of the output, to not find correlations between input bits and output bits. In order to have avalanche effect there need to be at least 7 rounds.</p>
<h4 id="feistel-cipher">Feistel Cipher</h4>
<p>Round functions are invertible regardless of the choice of the function and works by switching right and left block and applying a function on the right with the key and xor it the left block for a new right block. The functions for encryption are</p>
<p>$$\displaylines{L_i\leftarrow R_{i-1},\R_i\leftarrow L_{i-1}\oplus F(K_i,R_{i-1})}$$</p>
<p>and decryption is done as</p>
<p>$$\displaylines{R_{i-1}\leftarrow L_i,\L_{i-1}\leftarrow R_i\oplus F(K_i,L_i)}$$</p>
<p>and the operations visually</p>
<p><img src="/images/IN4191/Feistel.png" alt="Feistel Cipher"></p>
<p>Security of Feistel ciphers depends on:</p>
<ul>
<li>the round keys (are they random looking, secure enough)</li>
<li>the number of rounds</li>
<li>security of function $F$</li>
</ul>
<h4 id="des-data-encryption-standard">DES (Data Encryption Standard)</h4>
<p>A Feistel cipher with <strong>16 rounds</strong>, <strong>64 bits block size</strong>, <strong>56 bit key length</strong>, and <strong>16 round keys, each 48 bits</strong>. It performs an initial permutation (IP), then runs the Feistel cipher, and then perform a reverse permutation ($IP^{-1}$).</p>
<p><img src="/images/IN4191/DES.png" alt="DES"></p>
<p>The 3DES version uses three different keys and runs DES 3 times.</p>
<p>The stages of the $F$ function are:</p>
<ol>
<li><strong>Expansion permutation</strong> where the right half of the 32 bits is expanded and permuted to 48 bits.</li>
<li><strong>Round key addition</strong> where the 48 bit input is xored with the round key</li>
<li><strong>Splitting</strong> the resulting 48 bits are split into eight lots of 6 bit values.</li>
<li><strong>S-Boxes</strong> each 6 bit value goes into an s-box and produces a 4 bit output. S-boxes present the non-linear component, as they are lookup tables that are 4x16 in size.</li>
<li><strong>P-Box</strong> the eight 4 bit lots are combined into 32 bits and are permuted.</li>
</ol>
<p>DES key scheduling takes the 56 bit key (it&rsquo;s 64 bits but 8 bits are parity bits for error detection at every 8th bit, so 8 16 &hellip; 64) and permutes the bits with the PC-1 permutation. The output of the permutation is divided into two 28 bit halfs $C_0$ the left half and $D_0$ the right. Each round we compute</p>
<p>$$C_i\leftarrow C_{i-1}\lll p_i,$$</p>
<p>$$D_i\leftarrow D_{i-1}\lll p_i$$</p>
<p>where $x \lll p_i$ means performing a cyclic shift on $x$ to the left by $p_i$ positions. If the round number is 1,2,9,16 we shift left by one position, otherwise by two. The two halfs $C_0$ and $D_0$ are joined back together and are permuted again with the PC-2 permutation. Visually depicted below</p>
<p><img src="/images/IN4191/DES_key_sched.png" alt="DES Key Scheduling"></p>
<p>Decryption is identical only keys will be used in reverse order.</p>
<h4 id="aes-advanced-encryption-standard">AES (Advanced Encryption Standard)</h4>
<p>AES is not a Feistel cipher but still has a round function. It is built on the mathematical foundation of finite fields (Galois fields). Galois fields are represented as $GF(p^m)$ with $p$ a prime number and $m$ an integer. Fields with value $m=1$ are prime fields and fields with $m\ge2$ are extension fields. Extension fields work with polynomials (have operations of addition, subtraction, multiplication, and non-negative exponentiation). Operations in the fields are in mod $p$ such that</p>
<p>$$a+b\equiv c \text{ mod } p$$</p>
<p>and</p>
<p>$$a*b\equiv c \text{ mod }p$$</p>
<p>and inverses are given as</p>
<p>$$a*a^{-1}\equiv 1 \text{ mod }p$$</p>
<p>where all variables come from the range of values in the set (e.g. $\mathbb{Z}_7=\{0,1,2,3,4,5,6\}$). Extension fields are represented in $m-1$ degree, for example with $GF(2^3)=GF(8)$ and is represented as</p>
<p>$$A(x)=a_2x^2+a_1x^1+a_0$$</p>
<p>shown with three different values for the coefficients (that can only be 0 or 1) as $(a_2,a_1,a_0)$. Then constructing all possible values for the coefficients we get the values for the field</p>
<p>$$GF(8)=\{0,1,x,x+1,x^2,x^2+1,x^2+x,x^2+x+1\}$$</p>
<p>Operations are still in mod $p$, such that for example in $GF(8)$ will be</p>
<p>$$(x^2+x)+(x^2+x+1)=((1+1)x^2+(1+1)x+1)\text{ mod }2=1$$</p>
<p>Operations subtraction and addition in the galois field of 2 $GF(2)$ are the same and are the same as doing an xor of the coefficients. For mutiplication with fields of degree larger than 2, to reduce the function to the original form</p>
<p>$$GF(x)=a_nx^n+a_{n-1}x^{n-1}+&hellip;+a_0$$</p>
<p>using an irreducible polynomial of degree $m-1$ with $m$ the degree of the multiplication result.</p>
<p>AES arithmetic is performed in modulo irreducible polynomial</p>
<p>$$m(x)=x^8+x^4+x^3+x+1$$</p>
<p>with 32-bit words with polynomial $F_{2^8}[X]$ of degree less than 4, such that</p>
<p>$$\displaylines{a_0||a_1||a_2||a_3\a_3<em>x^3+a_2</em>x^2+a_1*x^1+a_0}$$</p>
<p>note the order of the coefficients is reversed to what they appear (using big-endian). Arithmetic on polynomials in $F_{2^8}[X]$ are modulo reducible polynomial $m(x)=x^4+1$, hence this is a ring rather than a field.</p>
<p>AES supports 128, 192, 256 bit blocks with respective keys 128, 192, and 256 bits. Block size 128 has 10 rounds, 192 has 12 rounds, and 256 has 14 rounds (add 2 per increase).</p>
<p>AES operates on a 4x4 matrix called the <em>state matrix</em>, keys are also held in a 4x4 matrix.</p>
<p>AES Operations:</p>
<ul>
<li>
<p><strong>SubBytes:</strong> two types of S-boxes exist in AES, one for encryption and one for decryption (one being the inverse of the other). Each byte of the state matrix is considered as an input into the S-Box.</p>
</li>
<li>
<p><strong>ShiftRows:</strong> performs a cyclic shift on the state matrix, where each row is shifted by a different offset.</p>
</li>
<li>
<p><strong>MixColumns:</strong> each column in the state matrix is taken in turn and a new colum is produced by applying it to the polynomial
<img src="/images/IN4191/AES_MixColumns.png" alt="AES MixColumns"></p>
</li>
<li>
<p><strong>AddRoundKey:</strong> the state matrix is xored with ($\oplus$) with the round key.</p>
</li>
</ul>
<p>AES can then be described with the following algorithms for encryption and decryption respectively</p>
<p><img src="/images/IN4191/AES_encrypt.png" alt="AES Encrypt"></p>
<p><img src="/images/IN4191/AES_decrypt.png" alt="AES Decrypt"></p>
<p>The round keys are computed from the main key, where each round key is a 32 bit word,  with substitution and permutation as follows</p>
<p><img src="/images/IN4191/AES_KeySched.png" alt="AES Key Schedule"></p>
<h4 id="modes-of-operation">Modes Of Operation</h4>
<p>Block ciphers are needed but as is they cannot be used in practice because of missing security notions (IND-CPA and IND-CCA).</p>
<p>There are many different operations but these are the 5 mainly used ones:</p>
<ul>
<li>
<p><strong>Electronic Code Book Mode (ECB):</strong> simplest operation that divides the message into blocks and encrypts them individually.
<img src="/images/IN4191/ECB.png" alt="ECB Operations">
The problems with this mode are that the same input block will result in the same output block (repetitions in english text), deletion is possible without detection, and replay attack is possible (insert blocks from other messages). This means it is <strong>not IND-PASS</strong> secure and <strong>not OW-CCA</strong> secure but <strong>is OW-CPA</strong> secure.</p>
</li>
<li>
<p><strong>Cipher Block Chaining (CBC):</strong> encrypt the message by xoring the ciphertext after encryption with the ciphertext of the previous message (IV for the first message).
<img src="/images/IN4191/CBC.png" alt="CBC Operations">
The problem with this mode is that it is sequential and cannot be parallelized, and single bit errors cause the whole block to be decrypted wrong and a single wrong bit in the next block. If IV is used once and never repeated it <strong>is IND-PASS</strong> secure, if IV is fixed it is deterministic and hence only <strong>IND-PASS</strong> secure and <strong>not CPA</strong> secure. A truly random IV <strong>is IND-CPA</strong> secure.</p>
</li>
<li>
<p><strong>Output Feedback Mode (OFB):</strong> a block cipher that can be used as stream cipher.
<img src="/images/IN4191/OFB.png" alt="OFB Operations">
with a fixed IV it is <strong>not IND-CPA</strong> secure and <strong>not OW-CPA</strong> secure. With a nonce it <strong>is IND-CPA</strong> secure.</p>
</li>
<li>
<p><strong>Cipher Feedback Mode (CFB):</strong> also a block cipher that can be used a stream cipher, but here the keystream output is generated by encrypting the ciphertext.
<img src="/images/IN4191/CFB.png" alt="CFB Operations">
with a nonce it is <strong>not IND-CPA</strong> secure but <strong>is OW-CPA</strong> secure.</p>
</li>
<li>
<p><strong>Counter Mode (CTR):</strong> the IV is increased for every block, therefore insertion/deletion is not possible as all following decryptions will be invalid.
<img src="/images/IN4191/CTR.png" alt="CTR Operation">
this <strong>is IND-CPA</strong> secure and it allows for parallel computations.</p>
</li>
</ul>
<p>Overall security for the different modes:</p>
<p><img src="/images/IN4191/MO_OW_Security.png" alt="Modes of Operations OW Security"></p>
<p><img src="/images/IN4191/MO_IND_Security.png" alt="Modes of Operation IND Security"></p>
<h4 id="obtaining-chosen-ciphertext-security">Obtaining Chosen Ciphertext Security</h4>
<p>All previous modes of operations are not CCA secure (the decryption oracle would decrypt any old message), in order to achieve this security we need to use authentication encryption modes.</p>
<ul>
<li>
<p><strong>Encrypt then MAC:</strong> append a message authentication code to the ciphertext. This is done by
<img src="/images/IN4191/MAC.png" alt="MAC">
and the message authentication code is applied to the ciphertext. This <strong>is IND-CCA secure</strong>.</p>
</li>
<li>
<p><strong>Encrypt and MAC:</strong> works in a similar way except the encryption is done on the ciphertext (not the plaintext). This is <strong>not IND-CPA</strong> secure.</p>
</li>
<li>
<p><strong>MAC then Encrypt:</strong> MAC the plaintext and then encrypt the MAC and the plaintext together.  With a deterministic MAC it is <strong>not IND-CPA</strong> secure.</p>
</li>
</ul>
]]></content></item><item><title>Lecture 5: Modern Stream Ciphers</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-5/</link><pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate><guid>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-5/</guid><description>Modern Stream Ciphers (Chapter 12) Encrypt bits rather than blocks as this is faster and easier to implement in hardware and software. Stream ciphers work by
$$c=m\oplus F_k(0)$$
and are IND-PASS secure if the PRF is secure.
Feedback shift registers are a standard way of producing a binary stream of data. These consist of a number of memory cells, where some of them are tapped that feed a feedback function. Registers are shifted down and the result from the feedback is shifted to the empty cell.</description><content type="html"><![CDATA[<h4 id="modern-stream-ciphers-chapter-12">Modern Stream Ciphers (Chapter 12)</h4>
<p>Encrypt bits rather than blocks as this is faster and easier to implement in hardware and software. Stream ciphers work by</p>
<p>$$c=m\oplus F_k(0)$$</p>
<p>and are IND-PASS secure if the PRF is secure.</p>
<p>Feedback shift registers are a standard way of producing a binary stream of data. These consist of a number of memory cells, where some of them are tapped that feed a feedback function. Registers are shifted down and the result from the feedback is shifted to the empty cell. Typically linear feedback shift registers (LFSRs) are used as these are easier to implement in hardware, and have a linear feedback function that is an xor of all the bits. Sequences will repeat after a a period $$N$$ such that</p>
<p>$$s_{N+i}=s_i$$</p>
<p>and $N$ can be a maximum of $2^L-1$ (-1 as we do not include all 0 bits)</p>
<p>The <em>connection polynomial</em> specifies the properties of the LFSR and is given in the form of</p>
<p>$$C(X)=1+c_1<em>X+c_2</em>X^2+&hellip;+c_L*X^L\in\mathbb{F}_2[X]$$</p>
<p><img src="/images/IN4191/LFSR.png" alt="LFSR"></p>
<p>and the characteristic polynomial is given as</p>
<p>$$G(X)=X^L*C(1/X)$$</p>
<h4 id="primitive-polynomial">Primitive Polynomial</h4>
<ul>
<li>If $C_L=0$ the polynomial is singular (not choosing the last register for connection polynomial).</li>
<li>If $C_L=1$ the polynomial is non-singular and there is a period (including the last register in the connection polynomial).
<ul>
<li>$C(X)$ is irreducible: and the period is the smallest $N$ such that $C(X)$ divides $1+X^N$</li>
<li>$C(X)$ is primitive: Every initial state produces an output sequence that is periodic and of exact period $2^L-1$</li>
</ul>
</li>
</ul>
<p>If $$N$$ is the period, then the characteristic f(x) is a factor of $1-X^N$. For example a shift register with 3 registers has a maximum sequence of $2^N -1=2^3 -1=7$, then the connection polynomial with maximum sequence is a factor of $1+X^7$ such that one of the factors from which we can build the connection polynomial with $C(X)=X^3+X+1$.</p>
<p>Linear feedback registers are not secure since they are linear, observing the $2L$ outputs with $L$ registers will reveal the connection polynomial since the first $L$ bits reveal the s values (initial values) and the remaining unknowns can be found with</p>
<p>$$s_j=\sum_{i=1}^Lc_i*s_{j-i}(\text{ mod 2})$$</p>
<h4 id="combining-lfsrs">Combining LFSRs</h4>
<p>Change the use of LFSRs in a non-linear way, that hides the linearity of them, by combining them.</p>
<p>The maximum length of combining registers will be given as 2 to the sum of all the lengths of the different registers used minus 1,</p>
<p>$$2^{\sum_{i=1}^L L_i}-1$$</p>
<p>Some of the most influential LFSR combination implementations are:</p>
<ul>
<li>Filter generator: Turns the output stream into a non linear function by applying function $f$ to it.</li>
<li>Alternating-step generator: Takes three different shift registers of the roughly same length and the first LFSR is the clock for the others, if it is output is on the second LFSR is clocked and the output of the third is repeated. If the value is zero, the third LFSR is clocked and the output of the second is reused. The final output is the xor of the second and third.</li>
<li>Shrinking generator: with two LFSRs, the output of the first decides the output of the second (if value is one the output is that of second LFSR, if zero it is nothing)</li>
<li>A5/1 generator: uses three LFSRs and based on the majority bit decides which LFSR to clock.</li>
<li>Trivium: uses three shift registers with a total 288 bits ($93+84+111$), which are fed into each other with a number of formulas. It is used in practice and has not been broken. The system is clocked 1152 times before the output is used.</li>
</ul>
]]></content></item><item><title>Lecture 4: Defining Security</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-4/</link><pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate><guid>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-4/</guid><description>Security Games (Chapter 2.2) Security games are used to define security for cryptographic components, which contain an adversary and a challenger, and the idea is that the adversary needs to reach a certain objective given data provided by the challenger. These are typically represented visually with the adversary in a box and the challenger outside with the data it provides. The advantage of an adversary $$A$$ is defined as a function bounded by time $$t$$ that the adversary spends to try to solve the problem.</description><content type="html"><![CDATA[<h4 id="security-games-chapter-22">Security Games (Chapter 2.2)</h4>
<p>Security games are used to define security for cryptographic components, which contain an adversary and a challenger, and the idea is that the adversary needs to reach a certain objective given data provided by the challenger. These are typically represented visually with the adversary in a box and the challenger outside with the data it provides. The advantage of an adversary $$A$$ is defined as a function bounded by time $$t$$ that the adversary spends to try to solve the problem. For RSA and SQRROOT games this is defined as</p>
<p>$$Adv_v^X(A,t)=Pr[A \text{ wins the game X for }v=log_2N \text{ in time less than }t]$$</p>
<p>Finding the quadratic residue of a value is done by checking all values that it comprises (i.e. with value 7, $\mathbb{Z}_7=\{0,1,2,3,4,5,6\}$), and squaring each containing value (except 0 of course) modulo the value itself. For the example with $\mathbb{Z}=7$ this will be,</p>
<p>$$\displaylines{1^2\equiv1 \text{ mod }7\<br>
2^2\equiv4 \text{ mod }7\<br>
3^2\equiv2 \text{ mod }7\<br>
4^2\equiv2 \text{ mod }7\<br>
5^2\equiv4 \text{ mod }7\<br>
6^2\equiv1 \text{ mod }7}$$</p>
<p>Where the residue class is all remainders, in this case $Q_7=\{1,2,4\}$.</p>
<p>For the QUADRES game, where the challenger picks a value $$a$$ to be a quadratic residue and the adversary guesses if it is a quadratic residue or not (50/50 chance with random guessing). Hence, the advantage is zero if the adversary just guesses, which makes the function</p>
<p>$$Adv_v^{QUADRES}(A)=2*\lvert Pr[A \text{ wins the QUADRES game for }v=log_2N]-\frac{1}{2}\lvert$$</p>
<h4 id="discrete-logarithms-chapter-31">Discrete Logarithms (Chapter 3.1)</h4>
<p>The discrete log problem (DLP) states that given a finite group $G$, and $g,h \in G$</p>
<p>$$g^x=h\text{ or }x=dlog_g(h)$$</p>
<p>in other words $a^x=y\text{ mod }p$, given $a$ and $y$ it is difficult to find $x$.</p>
<h3 id="defining-security-chapter-11">Defining Security (Chapter 11)</h3>
<p>Three aspects of modern cryptography:</p>
<ul>
<li><strong>Definitions:</strong> The first challenge for modern cryptography is to arrive at a concrete mathematical definition of what it means for a particular cryptographic mechanism to be secure.</li>
<li><strong>Schemes:</strong> Once it has a security definition, we want to design schemes which it hoped will meet the security definition (i.e. system whose security relies on factoring large numbers).</li>
<li><strong>Proofs:</strong> Ask whether the design meets the security definition.</li>
</ul>
<p>A pseudo random function (PRF) is a function that appears random to the adversary, such that he cannot predict the output.</p>
<p>In the security game, instead of giving the adversary the Function $F$ and value pair (x,y), the adversary is provided with a family of functions $\{F_k\} K$ from which one function is chosen with private key $K$ and the adversary has access to an oracle for querying function applications. This is done, as if the adversary is supplied directly with the function, he can directly apply the function and win, and without the oracle the adversary would have no chance. The PRF security game will be,</p>
<p><img src="/images/IN4191/PRF_sec_game.png" alt="PRF_sec_game"></p>
<h4 id="one-way-functions-and-trapdoor-one-way-functions">One-Way Functions and Trapdoor One-Way Functions</h4>
<p>One way functions (OWF) work by giving the adversary a public function and asking him to invert the function on an element of the challenger&rsquo;s choosing, shown below</p>
<p><img src="/images/IN4191/OWF_sec_game.png" alt="OWF_sec_game"></p>
<p>Examples of OWFs are the discrete logarithm problem and RSA, but RSA also has an extra value $d$ for efficiently inverting the function, called the <em>trapdoor</em>.</p>
<h4 id="public-key-cryptography">Public Key Cryptography</h4>
<p>Users hold a public and private key pair, where the public key is used to encrypt messages and send them to the user and the private key is the only one that can decrypt the message. The keys are linked in a mathematical way such that obtaining the private key from the public key is difficult but the public from private is easy.</p>
<h4 id="security-of-encryption">Security of Encryption</h4>
<p>Different types of attacks:</p>
<ul>
<li>
<p><strong>PASS:</strong> Passive attack where the adversary should not learn the message underlying a specific ciphertext. E.g. OW-PASS depicted below, the same applies to public key crypto with public and private key pairs
<img src="/images/IN4191/OW_PASS.png" alt="ow-pass"></p>
</li>
<li>
<p><strong>CPA:</strong> Chosen plaintext attack where the adversary also has access to an oracle for encrypting a chosen plaintext. This is done as with PASS, the adversary has very limited power.
E.g. in symmetric crypto this would be as follows,
<img src="/images/IN4191/OW_CPA.png" alt="OW-CPA">
Note that in the previous game with public crypto, it is also CPA as the adversary has the public key and can encrypt whatever plaintext he chooses.</p>
</li>
<li>
<p><strong>CCA:</strong> Chosen ciphertext attack gives the adversary an oracle to decrypt chosen ciphertexts, except of course decrypting the original ciphertext. This game looks as follows for symmetric and public crypto,
<img src="/images/IN4191/OW-CCA.png" alt="OW-CCA">
As this notion only provides a sense of fully breaking the encryption but not retrieving parts of the message, there are additional security classifications about how secure a message should be, such that the adversary cannot retrieve any information about the plaintext.</p>
</li>
<li>
<p><strong>Perfect Security:</strong> As was seen in earlier chapters, perfect security is when the adversary cannot gain any information about the message, by using a key with the same length as the plaintext. This is not used in practice as it is highly unpractical.</p>
</li>
<li>
<p><strong>Semantic Security:</strong> Similar to perfect security but the run time of the adversary is bounded by a polynomial function of the underlying security parameter (i.e. the key size).</p>
</li>
<li>
<p><strong>IND Security:</strong> As semantic security is difficult to show, indistinguishability (IND) is easier to show and a system that is IND secure is also semantically secure. IND works in two stages,</p>
<ul>
<li><strong>Find</strong> stage where the adversary produces two plaintexts of the same length</li>
<li><strong>Guess</strong> stage where the adversary is given the encryption of one of the plaintexts ($$m_b$$) and has to guess the bit $$b$$ with probability greater than one half.</li>
</ul>
</li>
</ul>
<p><img src="/images/IN4191/IND-CCA.png" alt="IND-CCA"></p>
<p>Any encryption function that is IND-CPA secure must be probabilistic.</p>
<p>Definition: A crypto algorithm is secure if it is semantically secure against a CPA attack.<br>
Definition: An encryption algorithm is secure if it is IND-CCA secure.<br>
Theorem: A system that is IND-PASS secure must be semantically secure against passive adversaries.</p>
<p>$$\displaylines{\prod \text{ is IND-CCA} \Longrightarrow\prod \text{ is IND-CPA}\Longrightarrow\prod\text{ is IND-PASS}\ \prod \text{ is IND-XXX}\Longrightarrow\prod\text{ is OW-XXX}}$$</p>
<h4 id="other-notions-of-security">Other Notions of Security</h4>
<ul>
<li>Many time security: How many times can we use the LR oracle?</li>
<li>Real or random: RoR oracle encrypts either the real message or a random message.</li>
<li>Lunchtime attack (CCA1): Adversary has the decryption oracle during the find stage for some time.</li>
<li>Nonce-based encryption: Deterministic algorithms are not IND-CPA secure, therefore use a nonce (number used once) to provide some randomness.</li>
<li>Data encapsulation mechanism: Symmetric system but the key is used only once.</li>
<li>Non-malleability: Based on having the ciphertext of an unknown plaintext, the adversary can compute a new ciphertext for a related plaintext.</li>
<li>Plaintext aware: It is computationally difficult to construct a valid ciphertext without being given the corresponding plaintext.</li>
</ul>
<p><img src="/images/IN4191/NotionsOfSec.png" alt="Notions of Security"></p>
<p>Random Oracle Model (ROM): All parties have a random function with domain {0,1}* and a finite codomain C, the challenger has the control of the oracle, and the adversary can call her. This kind of function cannot exist in the real world, but hash functions act as such an oracle.</p>
]]></content></item><item><title>Lecture 3: Information Theoretic Security</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-3/</link><pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate><guid>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-3/</guid><description>Information Theoretic Security (Chapter 9) A crypto system is said to be computationally secure if the best possible algorithm for breaking it requires $$N$$ operations, where $$N$$ is some large number above $2^{128}$. It is impossible to prove that a system is computationally secure, as we do not know if there is a better algorithm for breaking it, hence a system is called secure if the best known algorithm requires a large number of computations.</description><content type="html"><![CDATA[<h3 id="information-theoretic-security-chapter-9">Information Theoretic Security (Chapter 9)</h3>
<p>A crypto system is said to be <em>computationally secure</em> if the best possible algorithm for breaking it requires $$N$$ operations,
where $$N$$ is some large number above $2^{128}$. It is impossible to prove that a system is computationally secure, as
we do not know if there is a better algorithm for breaking it, hence a system is called secure if the best <em>known</em> algorithm
requires a large number of computations.</p>
<p><em>Provably secure</em> systems are reduced to breaking the system by solving some well studied hard problem (i.e. factorizing large
numbers).</p>
<p>A system is said to be <em>unconditionally secure</em> if the adversary has unlimited computational power but still cannot break
the system.</p>
<h4 id="probability-and-ciphers">Probability and Ciphers</h4>
<p>Given $\mathbb{P}$ the space of possible plaintexts, $\mathbb{K}$ the space of possible keys, and $\mathbb{C}$ the space of possible ciphertexts,
the probability that $p(C=c)$ is given as,</p>
<p>$$p(C=c) = \sum_{k:c\in \mathbb{C}(k)}p(K=k)*p((P=d_k(c)))$$</p>
<p>For example, given four messages $\mathbb{P}$={a,b,c,d} with probability of occurring</p>
<ul>
<li>p(P=a) = 1/4</li>
<li>p(P=b) = 3/10</li>
<li>p(P=c) = 3/20</li>
<li>p(P=d) = 3/10</li>
</ul>
<p>and keys $\mathbb{K}$={$k_1,k_2,k_3$} with probabilities</p>
<ul>
<li>p($K=k_1$) = 1/4</li>
<li>p($K=k_2$) = 1/2</li>
<li>p($K=k_3$) = 1/4</li>
</ul>
<p>and resulting $\mathbb{C}$={1,2,3,4} with</p>
<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td>$k_1$</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>$k_2$</td>
<td>3</td>
<td>1</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>$k_3$</td>
<td>4</td>
<td>3</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>then different probabilities can be computed</p>
<p>$$\displaylines{
p(C=1)=p(K=k_1)<em>p(P=d)+p(K=k_2)</em>(P=b)+p(K=k_3)*p(P=c)=0.2625\<br>
p(C=2)=p(K=k_1)<em>p(P=c)+p(K=k_2)</em>(P=d)+p(K=k_3)*p(P=d)=0.2625\<br>
p(C=3)=p(K=k_1)<em>p(P=a)+p(K=k_2)</em>(P=a)+p(K=k_3)*p(P=b)=0.2625\<br>
p(C=4)=p(K=k_1)<em>p(P=b)+p(K=k_2)</em>(P=c)+p(K=k_3)*p(P=a)=0.2125}$$</p>
<p>As can be seen ciphertexts are almost uniformly distributed. Based of this we can compute the conditional probability that c is the ciphertext given plaintext m with</p>
<p>$$p(C=c|P=m)=\sum_{k:m=d_k(c)}p(K=k)$$</p>
<p>Which is the sum of probabilities over all of the keys where the input plaintext m gives the resulting ciphertext x. For the example this will be as follows,</p>
<p>$$\displaylines{
\begin{aligned}p(C=1|P=a)= 0, \quad &amp;p(C=2|p=a)=0, \ p(C=3|P=a)=0.75, \quad &amp;p(C=4|P=a)=0.25\<br>
p(C=1|P=b)= 0.5, \quad &amp;p(C=2|p=b)=0, \ p(C=3|P=b)=0.25, \quad &amp;p(C=4|P=b)=0.25\<br>
p(C=1|P=c)= 0.25, \quad &amp;p(C=2|p=c)=0.25, \ p(C=3|P=c)=0, \quad &amp;p(C=4|P=c)=0.5\<br>
p(C=1|P=d)= 0.25, \quad &amp;p(C=2|p=d)=0.75, \ p(C=3|P=d)=0, \quad &amp;p(C=4|P=d)=0
\end{aligned}}$$</p>
<p>With said probability we can calculate the probability of a plaintext m given ciphertext c,</p>
<p>$$p(P=m|C=c)=\frac{p(P=m)*p(C=c|P=m)}{p(C=c)}$$</p>
<h4 id="perfect-secrecy">Perfect Secrecy</h4>
<p>A system with the property that the ciphertext does not reveal any information about the plaintext. So,</p>
<p>$$p(P=m|C=c)=p(P=m)$$</p>
<p>Shannon&rsquo;s theorem on perfect secrecy says a crypto system is perfectly secure <em>iff</em></p>
<ul>
<li>every key is used with equal probability 1/#$\mathbb{K}$</li>
<li>for each m $\in\mathbb{P}$ and c $\in \mathbb{C}$ there is a unique key k such that $e_k(m)=c$</li>
</ul>
<h4 id="vernam-cipher-one-time-pad">Vernam Cipher (one-time pad)</h4>
<p>Uses a binary key that is as long as the message to be encrypted and each of the plaintext bits is xor with the key bit, and each key is only allowed to be used once.</p>
<h4 id="entropy">Entropy</h4>
<p>Keys as long as messages are impractical in modern crypto systems, therefore systems will not be unconditionally secure but are hoped to be computationally secure.</p>
<p>Given a random variable $X$ which takes on a finite set of values $x_i$ and has probability distribution $p_i=p(X=x_i)$ entropy is given as</p>
<p>$$H(X)=-\sum_{i=1}^np_i*log_2p_i$$</p>
<p>Joint probability is given as</p>
<p>$$H(X,Y)=-\sum_{i=1}^n\sum_{j=1}^jr_{i,j}*log_2r_{i,j}$$</p>
<p>and conditional probability as</p>
<p>$$H(X|Y=y)=-\sum_{x}p(X=x|Y=y)*log_2 p(X=x|Y=y)$$</p>
<p>the conditional probability can then be simplified as follows</p>
<p>$$\displaylines{H(X|Y)=\sum_yp(Y=y)*H(X|Y=y) \<br>
=-\sum_x\sum_yp(Y=y)*p(X=x|Y=y)*log_2p(X=x|Y=y)}$$</p>
<p>which presents the amount of uncertainty that is left about $$X$$ if $$Y$$ is revealed.</p>
<p>$$H(X,Y)=H(Y)+H(X|Y)$$</p>
<p>The <em>key equivocation</em> property is what uncertainty is left about the key after a ciphertext is revealed, and is stated as</p>
<p>$$H(K,C)=H(K)+H(P)-H(C)$$</p>
<h4 id="spurious-keys-and-unicity-distance">Spurious Keys and Unicity Distance</h4>
<p>When information about a key is leaked by a ciphertext, a certain ciphertext rules out a subset of the keys, the remaining possible, but incorrect keys, are called <em>spurious keys</em>.</p>
<p>The entropy of a natural language is calculated as</p>
<p>$$H_L=\lim_{n\rightarrow\infty}\frac{H(P^n)}{n}$$</p>
<p>The redundancy of a language is given as</p>
<p>$$R_L=1-\frac{H_L}{log_2#P}$$</p>
<p>and expresses the percentage of the text in the language that can be removed without losing its meaning.</p>
<p>The <em>unicity distance</em> of a cipher is the average number of ciphertexts for which the expected number of spurious keys becomes zero. It presents the average amount needed of a ciphertext before an attacker can determine the key (assume infinite compute power). It is calculated as</p>
<p>$$\displaylines{\overline{s}_n\ge\frac{#\mathbb{K}}{#\mathbb{P}^{n<em>R_L}}-1\<br>
n_0\approx\frac{log_2#\mathbb{K}}{R_L</em>log_2#\mathbb{P}}}$$</p>
]]></content></item><item><title>Lecture 2: Classical Systems</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-2/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate><guid>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-2/</guid><description>Classical Systems (Chapter 7) An encryption algorithm or cipher is the transformation of plaintext to ciphertext with a secret key, depicted as
$$c=e_k(m)$$
with $m$ being the plaintext,
$e$ being the cipher function,
$k$ being the secret key,
$c$ being the ciphertext
The reverse process is called decryption or decipherment, depicted as
$$m=d_k(c)$$
The key above needs to be known to both parties, but must be kept secret from all others.</description><content type="html"><![CDATA[<h3 id="classical-systems-chapter-7">Classical Systems (Chapter 7)</h3>
<p>An encryption algorithm or cipher is the transformation of plaintext to ciphertext with a secret key, depicted as</p>
<p>$$c=e_k(m)$$</p>
<p>with $m$ being the plaintext,<br>
$e$ being the cipher function,<br>
$k$ being the secret key,<br>
$c$ being the ciphertext</p>
<p>The reverse process is called decryption or decipherment, depicted as</p>
<p>$$m=d_k(c)$$</p>
<p>The key above needs to be known to both parties, but must be kept secret from all others. These encryption schemes are
called <em>symmetric cryptosystems</em>.<br>
Another form of system that uses different types of keys; public key for encryption and private key for decryption, is
known as an <em>asymmetric cryptosystem</em> or <em>public key cryptosystem</em></p>
<p>Historical ciphers can easily be broken with <em>Cryptanalysis</em> based on the properties of the underlying language (english). The frequencies of
most commonly appearing letters (E and T) will be visible in certain ciphers, or the most common bigrams (TH and HE), or trigrams (THE and ING).</p>
<h4 id="kerckhoffs-principle">Kerckhoff&rsquo;s Principle</h4>
<p>&ldquo;The method must not be required to be secret, and it must be able to fall into the hands of the enemy without inconvenience.&rdquo;</p>
<h4 id="shift-cipher">Shift Cipher</h4>
<p>One of the simplest ciphers is the shift cipher, which shifts the letters in the alphabet based on some key.
Commonly called the Ceasar cipher, as he used this algorithm with a key of three. For example with 3 as a key, the
letter A would become the letter D. ($c=m+k$ mod 26)</p>
<p>Each letter in the alphabet is associated with a number (0-25), which is used to convert plaintext into a sequence of
numbers and then shifted by adding the key to each value modulo 26. Hence, this cipher is a <em>stream cipher</em> calculating
on an incoming stream of values from the converted plaintext.</p>
<p>Breaking the shift cipher with statistical distance given as</p>
<p>$$\Delta[X,Y]=\frac{1}{2}\sum_{u\in V} \displaystyle\left\lvert \underset{X \leftarrow D_1}{Pr} [X=u]-
\underset{Y \leftarrow D_2}{Pr} [Y=u] \right\rvert$$</p>
<p>with random variables $X$ and $Y$, $V$ the support of $X$ and $Y$ (all values which can occur for $X$ and
$Y$ with non-zero probability). After doing this calculation with all possible values for key $k$ the result will be
26 different distributions. The one with the lowest is the one most likely to be the key.</p>
<h4 id="substitution-cipher">Substitution Cipher</h4>
<p>Problem with shift cipher is too small key space, substitution uses a permutation of the alphabet to substitute each letter
with a letter from the permutation using a chosen permutation. Here the key space is equal to the number of possible
permutations $26!\approx 4.03*10^{26}\approx 2^{88}$.</p>
<p>Feasibility of brute forcing is given as under $2^{80}$ steps.</p>
<p>Substitution cipher can still be broken using statistical distance as with the shift cipher, and the details of the
underlying language.</p>
<h4 id="vigénere-cipher">Vigénere Cipher</h4>
<p>Problem in the substitution cipher is that each plaintext letter always corresponds to the same ciphertext letter.
A solution is to use a polyalphabetic substitution cipher, similar to the regular substitution cipher but with 2 different
permutations, where even numbers of the plaintext are substituted with one permutation and odd numbers with the other.
This way, different plaintext letters can map to the same ciphertext letter, making it harder to find underlying
information of the language. With 5 different alphabets, the key space becomes</p>
<p>$$(26!)^5\approx2^{441}$$</p>
<p>But it&rsquo;s hard to remember the key, hence there is the vigénere cipher. Where the key is a word, which is continuously repeated.
The same problem arises that once the length of the key is known, the cipher can be broken using the Kasiki test to first
find the length of the keyword by looking at the distances of commonly appearing bigrams and trigrams and finding their
greatest common divisor (gcd). Then with the length of the keyword look at every first letter of the key length (i.e. with key 5, letters 0,5,10&hellip;)
and use statistics to find the plaintext letter.</p>
<h4 id="permutation-cipher">Permutation Cipher</h4>
<p>Permuatation ciphers work by having a permuatation $\sigma \in S_n$, for example</p>
<p>$$ \sigma =
\begin{pmatrix}
1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \<br>
2 &amp; 4 &amp; 1 &amp; 3 &amp; 5
\end{pmatrix}
=(1243) \in S_5$$</p>
<p>Taking the plaintext and splitting it into all lowercase 5 letter chunks, one can use the defined permutation to encrypt
the plaintext one chunk at a time. Then spaces can be removed to hide underlying structure of the language.
This can be broken by asking for a permutation of a plaintext of your choosing and deducing the permutation from the
given ciphertext and the chosen plaintext. Sequences will repeat key at modulo $$n$$. For example, asking to encrypt</p>
<p><strong>abcdefghijklmnopqrstuvwxyz</strong> and obtaining ciphertext</p>
<p><strong>cadbehfigjmknlorpsqtwuxvyz</strong> gives the resulting permutation of</p>
<p>$$\begin{pmatrix}
1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10 &amp; &hellip; \<br>
2 &amp; 4 &amp; 1 &amp; 3 &amp; 5 &amp; 7 &amp; 9 &amp; 6 &amp; 8 &amp; 10 &amp; &hellip;
\end{pmatrix}$$</p>
<p>where modulo 5 the permutation starts repeating.</p>
]]></content></item><item><title>Lecture 1: Introduction</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-1/</link><pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate><guid>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-1/</guid><description>What is Security? Security means:
Confidentiality: Access to systems or data is limited to authorized parties.
Integrity: When you receive data, you get the &amp;ldquo;right&amp;rdquo; data.
Availability: The system or data is there when you want it.
Objectives of Cryptography - Message authentication: valid message? - Data origin authentication: valid sender? - Entity authentication: authenticate each other for communication Kerckhoff&amp;rsquo;s principle: The adversary knows all details about the crypto system except the private key.</description><content type="html"><![CDATA[<h4 id="what-is-security">What is Security?</h4>
<p>Security means:</p>
<p><strong>C</strong>onfidentiality: Access to  systems or data is limited to authorized parties.<br>
<strong>I</strong>ntegrity: When you receive data, you get the &ldquo;right&rdquo; data.<br>
<strong>A</strong>vailability: The system or data is there when you want it.</p>
<h4 id="objectives-of-cryptography">Objectives of Cryptography</h4>
<pre><code>- Message authentication: valid message?
- Data origin authentication: valid sender?
- Entity authentication: authenticate each other for communication
</code></pre>
<p>Kerckhoff&rsquo;s principle: The adversary knows all details about the crypto system except the private key.</p>
<p>$Enc_k$: plaintext to ciphertext<br>
$Dec_k$: ciphertext to plaintext<br>
Encryption key: $k$<br>
Decryption key: $k'$</p>
<p>if $k=k'$, symmetric key or private key encryption<br>
if $k \neq k'$, asymmetric key or public key encryption</p>
<h4 id="information-theoretic-security">Information Theoretic Security</h4>
<p>Entropy:</p>
<p>$$-\sum_{i=1}^np_i*log_2p_i$$</p>
]]></content></item><item><title>Info</title><link>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/info/</link><pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate><guid>https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/info/</guid><description>IN4191 Security and Cryptography notes at TUDelft (Q1).
Studyguide: https://studiegids.tudelft.nl/a101_displayCourse.do?course_id=55221
Book: Nigel P. Smart. 2015. Cryptography Made Simple (1st. ed.). Springer Publishing Company, Incorporated.
All content and images are based on and retrieved from the book and the lecture slides.</description><content type="html"><![CDATA[<p>IN4191 Security and Cryptography notes at TUDelft (Q1).</p>
<p>Studyguide: <a href="https://studiegids.tudelft.nl/a101_displayCourse.do?course_id=55221">https://studiegids.tudelft.nl/a101_displayCourse.do?course_id=55221</a><br>
Book: Nigel P. Smart. 2015. Cryptography Made Simple (1st. ed.). Springer Publishing Company, Incorporated.</p>
<p>All content and images are based on and retrieved from the book and the lecture slides.</p>
]]></content></item></channel></rss>