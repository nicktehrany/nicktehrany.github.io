<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="IN4191 Security and Cryptography Notes"><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-9/><title>Lecture 9: The RSA Algorithm :: Nick Tehrany</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/main.d7bdd8ee18bfbf4c605488a7e5b1b92cd980dfeed2bdaeab4dd5e931a7a78bc0.css><meta itemprop=name content="Lecture 9: The RSA Algorithm"><meta itemprop=description content="IN4191 Security and Cryptography Notes"><meta itemprop=datePublished content="2021-01-13T00:00:00+00:00"><meta itemprop=dateModified content="2021-01-13T00:00:00+00:00"><meta itemprop=wordCount content="935"><meta itemprop=image content="https://nicktehrany.github.io"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://nicktehrany.github.io"><meta name=twitter:title content="Lecture 9: The RSA Algorithm"><meta name=twitter:description content="IN4191 Security and Cryptography Notes"><meta property="og:title" content="Lecture 9: The RSA Algorithm"><meta property="og:description" content="IN4191 Security and Cryptography Notes"><meta property="og:type" content="article"><meta property="og:url" content="https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-9/"><meta property="og:image" content="https://nicktehrany.github.io"><meta property="article:published_time" content="2021-01-13T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-13T00:00:00+00:00"><meta property="og:site_name" content="Nick Tehrany"><meta property="article:published_time" content="2021-01-13 00:00:00 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>$</span>
<span class=logo__text>cd nicktehrany</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/projects>Projects</a></li><li><a href=/publications>Publications</a></li><li><a href=/thesis>Theses</a></li><li><a href=/notes>Uni Notes</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=posts><div class=post-info><p></p></div><article><h1 class=post-title><a href=https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-9/>Lecture 9: The RSA Algorithm</a></h1><div class=post-content><h2 id=the-rsa-algorithm-chapter-15>The RSA Algorithm (Chapter 15)</h2><p>The RSA algorithm is based on the difficulty of the RSA problem that it is difficult to to find $d$ given a large composite number $N$ and $e$. It works by taking two large secret prime numbers $p$ and $q$ and computing $N=p*q$. Then picking an encryption exponent $e$ that satisfies</p><p>$$\text{gcd}(e,(p-1)*(q-1))=1$$</p><p>It is common to chose values $e=3,17,65537$. Now the public key will be shared as the pair of $\mathfrak{pC}=(N,e)$. The private key is computed by applying the extended euclidean algorithm on $e$ and $(p-1)(q-1)$ to obtain the decryption exponent $d$ that satisfies</p><p>$$e*d=1\text{ mod }(p-1)(q-1)$$</p><p>The secret key can be kept as just $\mathfrak{sK}=(d)$ or $\mathfrak{sK}=(d,p,b)$</p><p><strong>Encryption</strong> can then simply be done by</p><p>$$c\leftarrow m^e\text{ mod }N$$</p><p>and <strong>decryption</strong> is done as</p><p>$$m\leftarrow c^d\text{ mod }N$$</p><p><img src=/images/IN4191/RSA-Proof.png alt="RSA Correctness"></p><h3 id=security-of-rsa>Security of RSA</h3><p>Computing $d$ given $e$ and $N$ is no harder than factoring $N$, so if you can factor $N$ you can compute $d$.</p><p>The current suggestion for medium term security is to use a modulo of 2048 bits.</p><p>RSA <strong>is OW-CPA</strong> secure, but <strong>not IND-CPA</strong> secure since the system is deterministic.</p><p>Additionally RSA is malleable due to <strong>homomorphism</strong>, stating that an encryption scheme has the (multiplicative) homomorphic property if given the encryptions of $m_1$ and $m_2$ we can determine the encryption of $m_1*m_2$ without knowing $m_1$ or $m_2$.</p><p>$$(m_1<em>m_2)^e\text{ mod }N=((m_1\text{}^e\text{ mod }N)</em>(m_2\text{}^e\text{ mod }N)) \text{ mod }N$$</p><p>RSA is <strong>not OW-CCA</strong> secure. This is proven by multiplying the challenger&rsquo;s ciphertext by two and having the oracle decrypt it. The oracle checks if the ciphertext is the original ciphertext, which it is not and will decrypt. But since you know the relationship to the original ciphertext, you can just divide the decrypted plaintext by 2 and retrieve the original message.</p><h3 id=rabin-encryption>Rabin Encryption</h3><p>Choose $p$ and $q$ such that $p=q=3\text{ mod }4$ and then use private key $\mathfrak{sK}=(p,q)$ and public key $\mathfrak{pK}=(N)$.</p><p>Encryption is done by computing $c\leftarrow m^2 \text{ mod } N$ and decryption as</p><p>$$m_p=\sqrt{c}\text{ mod }p=c^{(p+1)/4}\text{ mod }p$$</p><p>$$m_q=\sqrt{c}\text{ mod }q=c^{(q+1)/4}\text{ mod }q$$</p><p>followed by applying the Chinese Remainder Theorem to combine $m_p$ and $m_q$.</p><p><strong>Is OW-CPA</strong> secure based on the factoring problem but the mapping is not injective, meaning that encryption produces one ciphertext but decryption produces 4 possible plaintexts.</p><p><strong>Not OW-CCA</strong> secure and <strong>not IND-CPA</strong> secure.</p><h3 id=the-naive-rsa-signature>The &ldquo;Naive&rdquo; RSA Signature</h3><p>Construct $d$ the same way as was done in RSA before, now senders sign a message by decrypting it and the receiver verifies the signature by encryption and obtains the message</p><p>$$\text{Signing: }s\leftarrow m^d\text{ mod }N$$</p><p>$$\text{Verification: }m\leftarrow s^e\text{ mod }N$$</p><h4 id=checking-validity-of-signatures>Checking Validity of Signatures</h4><p>We need to check the validity of signatures, which means that padding is required. Padding in RSA works with message $m$ is $t$ bits, and $N$ is $k$ bits with $t&lt;k-32$ bits. Pad $m$ with zeros on the left to make it a multiple of 8 bits and add $(k-t)/8$ bytes to the left of $m$ such that</p><p>$$m\leftarrow 00||01||FF||FF &mldr;||FF||00||m$$</p><p>This way of padding prevents trivial selective forgery.</p><h4 id=selective-forgery>Selective Forgery</h4><p>If there is a signing oracle and the attacker wants to obtain a signature $s$ of $m$, he generates a random message $m_1\in \mathbb{Z}_N^*$ such that</p><p>$$m_2 \leftarrow \frac{m}{m_1}$$</p><p>then asking the oracle to sign $m_1$ and $m_2$ and getting the individual signatures to construct the original one</p><p>$$s_i=m_i^d\text{ mod } N$$</p><p>$$s\leftarrow s_1*s_2\text{ mod }N$$</p><p>since</p><p>$$s=s_1*s_2\text{ mod }N$$</p><p>$$=m_1^d*m_2^d\text{ mod }N$$</p><p>$$=(m_1*m_2)^d\text{ mod }N$$</p><p>$$=m^d\text{ mod } N$$</p><p>Hence, by applying this kind of padding the homomorphism is destroyed.</p><h4 id=signing-documents>Signing Documents</h4><p>Divide the message $m$ into blocks, serial numbers and redundancy is needed, but signing data one by one is very inefficient, since RSA decryption is very slow due to the large value of $d$.</p><p>To solve it we do not want to sign every block, but hash the message and sign the hash but send the signed hash as a pair with the message, and the receiver will calculate the hash of the message and compare that to the received hash.</p><p><img src=/images/IN4191/RSA-Sign_Docs.png alt="RSA Signing Documents"></p><p>For this system to be secure, the hash function needs to be secure (preimage-, second preimage-, and collision- resistance).</p><h4 id=more-security-of-rsa>More Security of RSA</h4><p><strong>Knowing $\phi(N)$ and $N$</strong> one can find $p$ and $q$, since $\phi(N)=(p-1)(q-1)=p*q-p-q+1=N-p-q-1$, and $S=N+1+\phi$, and $S=p+q$, then we have</p><p>$$f(X)=(X-p)(X-q)=X^2-S*X+N$$</p><p>$$p=\frac{S+\sqrt{S^2-4*N}}{2}$$</p><p>$$q=\frac{S-\sqrt{S^2-4*N}}{2}$$</p><p><strong>Using a shared modulus</strong> (using the same $p$ and $q$), the attacker can trivially calculate $d$. In the first case, bob and the attacker are sharing a modulus (and bob is index 2), the attacker can calculate $d$ using $e_2*d_2\equiv 1\text{ mod }\phi(N)$.</p><p>In the second case, if the attacker can obtain two different ciphertexts for the same plaintext by both other parties, he can find the keys</p><p><img src=/images/IN4191/RSA-Shared-Modulus.png alt="Shared Modulus"></p><p><strong>Using a small public exponent</strong>, suppose there are three parties and they all use the same small public exponent, then</p><p><img src=/images/IN4191/RSA-Small_EXP.png alt="Small exponent"></p><p><strong>Wiener&rsquo;s Attack</strong> If one wants to speedup the performance by choosing a smaller value for the private exponent $d$, this will lead to a large value of the encryption exponent $e$ and we cannot choose too small a value for $d$, otherwise an attacker could find $d$ using exhaustive search. But it turns out that $d$ needs to be at least the size of $\frac{1}{3}*N^{1/4}$, otherwise one could attack using Wiener&rsquo;s attack.</p><p>The attack uses continued fractions to give a linear time algorithm to determine the private exponent when it is less than $\frac{1}{3}*N^{1/4}$.</p><h4 id=fault-analysis>Fault Analysis</h4><p>Fault analysis is the introduction of faults into a system and tricking it into doing some calculation incorrectly, by for example altering the environment, heating or cooling the chip, or by damaging the circuit in some way.</p><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>935 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2021-01-13</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-10/><span class=button__icon>←</span>
<span class=button__text>Lecture 10: Public Key Encryption and Signature Algorithms</span></a></span>
<span class="button next"><a href=https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-8/><span class=button__text>Lecture 8: Number Theory and Elliptic Curves</span>
<span class=button__icon>→</span></a></span></div></div></main></div><footer class=footer><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css><div><div>&nbsp; <a href=https://github.com/nicktehrany target=_blank rel=noopener title=Github><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a>&nbsp;&nbsp; <a href=https://www.linkedin.com/in/nicktehrany/ target=_blank rel=noopener title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a>&nbsp;
<a href=/misc/cv.pdf target=_self><i class="ai ai-cv ai-2x"></i></a></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>Themed by <a href=https://github.com/rhazdon/hugo-theme-hello-friend-ng>Hello Friend NG</a></span></div></div></footer></div><script type=text/javascript src=/bundle.min.af435e44374f1e99a669ea8cd5bb9a2fceed80588941a451bfddb66b86a67c9f40b0f417e9543a763f809aa7e9300d7b1d69bf99615810ba02ac70396d50fad5.js integrity="sha512-r0NeRDdPHpmmaeqM1buaL87tgFiJQaRRv922a4amfJ9AsPQX6VQ6dj+AmqfpMA17HWm/mWFYELoCrHA5bVD61Q=="></script></body></html>