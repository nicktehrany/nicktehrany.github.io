<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="IN4191 Security and Cryptography Notes"><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-10/><title>Lecture 10: Public Key Encryption and Signature Algorithms</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/main.89fa80e2143f71bd5c96a7c94e531dec3276a367e22f87e74a76026ab64680bf.css><meta itemprop=name content="Lecture 10: Public Key Encryption and Signature Algorithms"><meta itemprop=description content="IN4191 Security and Cryptography Notes"><meta itemprop=datePublished content="2021-01-14T00:00:00+00:00"><meta itemprop=dateModified content="2021-01-14T00:00:00+00:00"><meta itemprop=wordCount content="1137"><meta itemprop=image content="https://nicktehrany.github.io"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://nicktehrany.github.io"><meta name=twitter:title content="Lecture 10: Public Key Encryption and Signature Algorithms"><meta name=twitter:description content="IN4191 Security and Cryptography Notes"><meta property="og:title" content="Lecture 10: Public Key Encryption and Signature Algorithms"><meta property="og:description" content="IN4191 Security and Cryptography Notes"><meta property="og:type" content="article"><meta property="og:url" content="https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-10/"><meta property="og:image" content="https://nicktehrany.github.io"><meta property="article:published_time" content="2021-01-14T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-14T00:00:00+00:00"><meta property="og:site_name" content="Nick Tehrany"><meta property="article:published_time" content="2021-01-14 00:00:00 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>$</span>
<span class=logo__text>cd nicktehrany</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/awards>Awards</a></li><li><a href=/publications>Publications</a></li><li><a href=/projects>Projects</a></li><li><a href=/posts>Blog</a></li><li><a href=/notes>Uni Notes</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=posts><div class=post-info><p></p></div><article><h1 class=post-title><a href=https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-10/>Lecture 10: Public Key Encryption and Signature Algorithms</a></h1><div class=post-content><h2 id=public-key-encryption-and-signature-algorithms-chapter-16>Public Key Encryption and Signature Algorithms (Chapter 16)</h2><h3 id=passively-secure-encryption-schemes>Passively Secure Encryption Schemes</h3><h4 id=goldwasser-micali-encryption>Goldwasser Micali Encryption</h4><p>Is based on the QUADRES problem, stating that given a composite integer $N$ and an integer $e$, it is hard to test if $a$ is a quadratic residue or not. This is given as checking if a value from the set $J_N$ of values that produce a jacobi symbol of 1 (hence might be quadratic residue) is in the set of real quadratic residues $Q_N$.</p><p>Key generation is done with $N=p*q$ two prime numbers and $y\in J_N \text{\\} Q_N$ (The set of pseudo-squares is the difference between the two sets). The secret key is given as $\mathfrak{sK}=(p,q)$ and the public key as $\mathfrak{pK}=(N,y)$.</p><p><img src=/images/IN4191/Goldwasser-Micali.png alt=Goldwasser-Micali></p><p>Encryption is for a single bit $b$ done by choosing a value</p><p>$$x\leftarrow \mathbb{Z}_N^*$$</p><p>and then computing</p><p>$$c\leftarrow y^b*x^2\text{ mod }N$$</p><p>Decryption is done by computing the legendre symbol of the ciphertext $(\frac{c}{p})$. If $b=0$, $c$ is a quadratic residue (+1), if $b=1$, $c$ is non-quadratic residue (-1). This scheme is very inefficient as you can only encrypt binary values one at a time.</p><p>It <strong>is IND-CPA</strong> secure as it is probabilistic and not deterministic due to choosing a new value $x$ and having a different ciphertext for the same plaintext every time.</p><p>It is <strong>not IND-CCA</strong> secure since the system is homomorphic, meaning an operation in the ciphertext domain corresponds to an operation in the plaintext domain (binary addition, which is xor).</p><h4 id=elgamal-encryption>ElGamal Encryption</h4><p>It uses a prime number $p$ such that $p-1$ is divisible by another prime number $q$, and element $g$ is an element in the finite field $p$ with an order $q$.</p><p>Key generation is done as secret key is $x\leftarrow [0,&mldr;,q-1]$ and public key is $h\leftarrow g^x\text{ mod }p$.</p><p>Encryption message $m$ in $G$ is done as generating randomness</p><p>$$k\leftarrow \{0,&mldr;,q-1\}$$</p><p>ciphertext</p><p>$$c_1\leftarrow g^k$$</p><p>$$c_2\leftarrow m*h^k$$</p><p>and output ciphertext</p><p>$$c\leftarrow (c_1,c_2)\in G*G$$</p><p>Decrypting $c=(c_1,c_2)$ is done as</p><p>$$\frac{c_2}{c_1\text{}^x}=\frac{m<em>h^k}{g^{x</em>k}}=\frac{m<em>g^{x</em>k}}{g^{x*k}}=m$$</p><p>It <strong>is IND-CPA</strong> secure but <strong>not IND-CCA</strong> secure due to multiplicative homomorphism.</p><p>This scheme introduces data expansion as the message with the ciphertext will have two pieces.</p><h4 id=carmichael-theorem>Carmichael Theorem</h4><p>Let $n=pq$ where $p$ and $q$ are large numbers, $\phi(n)$ is Euler&rsquo;a totient function and $\lambda(n)=lcm(p-1,q-1)$. For any</p><p>$$w\in \mathbb{Z}_{n^2}^*$$</p><p>$$w^\lambda=1\text{ mod }n$$</p><p>$$w^{n\lambda}=1\text{ mod }n^2$$</p><h4 id=pallier-encryption>Pallier Encryption</h4><p>Based on the difficulty of factoring large integers. Key generation is done with $n=p*q$ and $g$ is a generator of the group</p><p>$$\mathbb{Z}_{N^2}^*$$</p><p>with an order of $n$ that is $g^n\equiv 1\text{ mod } n^2$ and $\lambda =lcm(p-1,q-1)$ (least common multiplier), where the secret key is $\lambda$ and the public key is $(g,n)$.</p><p>Encryption is done as</p><p>$$m\in \mathbb{Z}_N\text{ and }r\in_R\mathbb{Z}_N^*$$</p><p>$$E_{pk}(m)=g^mr^n\text{ mod }n^2$$</p><p>Decryption is done as</p><p>$$D_{sk}(c)=\frac{L(c^\lambda\text{ mod }n^2)}{L(g^\lambda\text{ mod }n^2)}\text{ mod }n$$</p><p>where $L(u)=\frac{u-1}{n}$.</p><p>It is probabilistic, hence it <strong>is IND-CPA</strong> secure, <strong>not IND-CCA</strong> secure since it is additively homomorphic (multiplication in the ciphertext corresponds to addition in the plaintext domain).</p><h4 id=rsa-oaep-optimized-asymmetric-encryption-padding>RSA-OAEP (Optimized Asymmetric Encryption Padding)</h4><p><img src=/images/IN4191/OAEP.png alt=OAEP></p><p>Function $f$ is any $k$-bit trapdoor one way permutation, $k_0$ and $k_1$ are numbers such that the effort of $2^{k_0}$ and $2^{k_1}$ is impossible ($k_0,k_1>128$ bits). $n=k-k_0-k_1$ and the hash functions</p><p>$$G:\{0,1\}^{k_0}\rightarrow \{0,1\}^{n+k_1}$$</p><p>$$H:\{0,1\}^{n+k_1}\rightarrow \{0,1\}^{k_0}$$</p><p>with message $m$ of $n$ bits then</p><p>$$c\leftarrow E(m)=f(\{(m||0^{k_1})\oplus G(R)\}||\{R\oplus H((m||0^{k_1})\oplus G(R))\})=f(A)$$</p><p>Decryption is done as</p><p><img src=/images/IN4191/OAEP-Decrypt.png alt="OAEP Decryption"></p><p>It <strong>is IND-CCA</strong> secure and <strong>is IND-CPA</strong> secure.</p><h4 id=fujisaki-okamoto-transform>Fujisaki-Okamoto Transform</h4><p>Using this transform to obtain IND-CCA secure schemes from IND-CPA secure schemes.</p><p>$$\text{Original scheme: }E(m,r)$$</p><p>$$\text{new scheme: }E&rsquo;(m,r)=E(m||r,H(m||r))$$</p><h3 id=hybrid-systems>Hybrid Systems</h3><p>In practice the KEM/DEM approach is used, meaning that data will be encrypted using a symmetric cipher and the key of the encryption is sent using an asymmetric cipher.</p><p><strong>KEM:</strong> Key encapsulation mechanism (public key component)</p><p><strong>DEM:</strong> Data encapsulation mechanism (private key component)</p><p>To encrypt a message $m$ to a user with $(\mathfrak{pk,sk})$, do</p><p>$$(k,c_1)\leftarrow Encap_{\mathfrak{pk}}()$$</p><p>$$c_2\leftarrow e_k(m)$$</p><p>$$c\leftarrow (c_1,c_2)$$</p><p>Upon receiving $c$ the recipient performs</p><p>$$k\leftarrow Decap_{\mathfrak{sk}}(c_1)$$</p><p>$$\text{If } k=\bot \text{ return }\bot$$</p><p>$$m\leftarrow d_k(c_2)$$</p><p>$$\text{return }m$$</p><h4 id=rsa-kem>RSA-KEM</h4><p>Let $N$ be RSA modulus, product of two primes $p$ and $q$, and function $f$ is RSA encryption, then encapsulation will be</p><p>$$x\leftarrow \{1,&mldr;,N-1\}$$</p><p>$$c\leftarrow f_{N,e}(x)$$</p><p>$$k\leftarrow H(x)$$</p><p>$$\text{Output }(k,c)$$</p><p>Decapsulation will be</p><p>$$x\leftarrow f_N^{-1}(c)$$</p><p>$$k\leftarrow H(x)$$</p><p>$$\text{Output }k$$</p><p>RSA-KEM <strong>is IND-CCA</strong> secure under ROM (Random Oracle Mode).</p><h4 id=dhies-kem>DHIES-KEM</h4><p>Diffie-Hellman Integrated Encryption Scheme uses a cyclic finite abelian group $G$ of prime order $q$ for key generation, as well as a key generator $g$, Key space $K$, key derivation function $H$, generate $x$ in $\mathbb{Z}_N$, and compute $h=g^x$.</p><p>Encapsulation and decapsulation are then given as</p><p><img src=/images/IN4191/DHIES-KEM.png alt=DHIES-KEM></p><p>This <strong>is IND-CCA</strong> secure if the hash function is secure.</p><h3 id=secure-signature-schemes>Secure Signature Schemes</h3><h4 id=rsa-fdh>RSA-FDH</h4><p>RSA-Full Domain Hash is a combination of RSA and hash functions for an efficient and secure signature scheme. It works by taking the hash of the message and signing it with the private key and upon receiving the signature is verified by using the public key and the calculated hash of the message, and comparing the two hashes. This scheme is secure but the codomain of the hash function needs to match the domain of RSA.</p><h4 id=rsa-pss>RSA-PSS</h4><p>RSA-Probabilistic Signature Scheme has $N$ as a RSA modulo of size $k$ bits with $e$ and $d$, and two parameters $k_0$ and $k_1$ such that $k_0+k_1&lt;k-1$ with the following hash functions</p><p>$$G: \{0,1\}^{k_1}\rightarrow \{0,1\}^{k-k_1-1}$$</p><p>$$H: \{0,1\}^*\rightarrow \{0,1\}^{k_1}$$</p><p>and</p><p>$$G_1: \{0,1\}^{k_1}\rightarrow \{0,1\}^{k_0}$$</p><p>$$G_2: \{0,1\}^{k_1}\rightarrow \{0,1\}^{k-k_0-1}$$</p><p>$$G(w)=g_1(w)||G_2(w)$$</p><p><img src=/images/IN4191/RSA-PSS.png alt=RSA-PSS></p><h4 id=dsa>DSA</h4><p>Digital Signature Algorithm exists because</p><ul><li>RSA based schemes are costly in terms of signature generation</li><li>RSA based signatures are large</li><li>RSA might be broken soon</li></ul><p>Digital signature algorithm is based on finite fields or elliptic curves.</p><p>It uses a large prime $p$ such that $p-1$ is divisible by another prime $q$, a generator $g$ of the finite field in mod $p$ with an order $q$, and a hash function that maps bit strings to $\mathbb{Z}_p$.</p><p>The secret key will be an integer $x$ in $[0,&mldr;,q-1]$ and the public key as $h=g^x$.</p><p><img src=/images/IN4191/DSA.png alt=DSA></p><h4 id=ec-dsa>EC-DSA</h4><p>Elliptic curve version of DSA, choose a random integer $a$ and a point $P$, where $a$ is the secret key, and compute the public key $Q=aP$</p><p><img src=/images/IN4191/EC-DSA.png alt=EC-DSA></p><p>Smaller key size due to elliptic curves and no exponentiations but point operations on the elliptic curve.</p><h4 id=schorr-signatures>Schorr Signatures</h4><p>$G$ is a public abelian group with generator $g$ of prime order $q$ with private key $x$ in $[0,&mldr;,q-1]$ and public key $h=g^x$.</p><p>Signing a message is done as</p><p>$$k\leftarrow \mathbb{Z}_q$$</p><p>$$r\leftarrow g^k$$</p><p>$$e\leftarrow H(m||r)$$</p><p>$$s\leftarrow k+x*e\text{ mod }q$$</p><p>Verification is done as</p><p>$$r\leftarrow g^s*h^{-e}$$</p><p>The signature is only valid if and only if $e=H(m||r)$.</p><h4 id=nyberg-rueppel-signature>Nyberg-Rueppel Signature</h4><p>If the message is small we can verify the signature and extract the message from it. This is a log based scheme with message recovery, but it requires redundancy (e.g. doubling the message by concatenating it twice $m||m$) which is easy to revert.</p><p>$G$ is a public abelian group with generator $g$ of prime order $q$ and private key $x=[0,&mldr;,q-1]$ and public key $h=g^x$.</p><p><img src=/images/IN4191/Nyberg-Ruppel.png alt=Nyber-Ruppel></p><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>1137 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2021-01-14</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-11/><span class=button__icon>←</span>
<span class=button__text>Lecture 11: Certificates, Key Transport, and Key Agreement</span></a></span>
<span class="button next"><a href=https://nicktehrany.github.io/notes/in4191-security-and-cryptography-notes/lecture-9/><span class=button__text>Lecture 9: The RSA Algorithm</span>
<span class=button__icon>→</span></a></span></div></div></main></div><footer class=footer><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css><div><div>&nbsp; <a href=https://github.com/nicktehrany target=_blank rel=noopener title=Github><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a>&nbsp;&nbsp; <a href=https://www.linkedin.com/in/nicktehrany/ target=_blank rel=noopener title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a>&nbsp;
<a href=/misc/cv.pdf target=_self><i class="ai ai-cv ai-2x"></i></a><a href=https://www.semanticscholar.org/author/Tehrany/2105151990 target=_self><i class="ai ai-semantic-scholar ai-2x"></i></a></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>Themed by <a href=https://github.com/rhazdon/hugo-theme-hello-friend-ng>Hello Friend NG</a></span></div></div></footer></div><script type=text/javascript src=/bundle.min.af435e44374f1e99a669ea8cd5bb9a2fceed80588941a451bfddb66b86a67c9f40b0f417e9543a763f809aa7e9300d7b1d69bf99615810ba02ac70396d50fad5.js integrity="sha512-r0NeRDdPHpmmaeqM1buaL87tgFiJQaRRv922a4amfJ9AsPQX6VQ6dj+AmqfpMA17HWm/mWFYELoCrHA5bVD61Q=="></script></body></html>