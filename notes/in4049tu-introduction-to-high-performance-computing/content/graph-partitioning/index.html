<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="ie=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=author content>
<meta name=description content="The goal with graph partitioning is that the entire graph is partitioned into even parts (about the same size/weight associated to the nodes/edged). However, choosing an optimal partitioning is NP-complete (can be proved that this is just as difficult as other hard problems in Nondeterministic Polynomial time). Therefore the only algorithms for partitioning have exponential cost on the number of nodes in the graph. This is why a heuristical approach is needed.">
<meta name=keywords content>
<meta name=robots content="noodp">
<meta name=theme-color content>
<link rel=canonical href=https://nicktehrany.github.io/notes/in4049tu-introduction-to-high-performance-computing/content/graph-partitioning/>
<title>
Graph Partitioning
</title>
<link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css>
<link rel=stylesheet href=/main.89fa80e2143f71bd5c96a7c94e531dec3276a367e22f87e74a76026ab64680bf.css>
<meta itemprop=name content="Graph Partitioning">
<meta itemprop=description content="The goal with graph partitioning is that the entire graph is partitioned into even parts (about the same size/weight associated to the nodes/edged). However, choosing an optimal partitioning is NP-complete (can be proved that this is just as difficult as other hard problems in Nondeterministic Polynomial time). Therefore the only algorithms for partitioning have exponential cost on the number of nodes in the graph. This is why a heuristical approach is needed."><meta itemprop=datePublished content="2022-01-22T19:10:04+01:00">
<meta itemprop=dateModified content="2022-01-22T19:10:04+01:00">
<meta itemprop=wordCount content="500"><meta itemprop=image content="https://nicktehrany.github.io">
<meta itemprop=keywords content>
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://nicktehrany.github.io">
<meta name=twitter:title content="Graph Partitioning">
<meta name=twitter:description content="The goal with graph partitioning is that the entire graph is partitioned into even parts (about the same size/weight associated to the nodes/edged). However, choosing an optimal partitioning is NP-complete (can be proved that this is just as difficult as other hard problems in Nondeterministic Polynomial time). Therefore the only algorithms for partitioning have exponential cost on the number of nodes in the graph. This is why a heuristical approach is needed.">
<meta property="og:title" content="Graph Partitioning">
<meta property="og:description" content="The goal with graph partitioning is that the entire graph is partitioned into even parts (about the same size/weight associated to the nodes/edged). However, choosing an optimal partitioning is NP-complete (can be proved that this is just as difficult as other hard problems in Nondeterministic Polynomial time). Therefore the only algorithms for partitioning have exponential cost on the number of nodes in the graph. This is why a heuristical approach is needed.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://nicktehrany.github.io/notes/in4049tu-introduction-to-high-performance-computing/content/graph-partitioning/"><meta property="og:image" content="https://nicktehrany.github.io"><meta property="article:section" content="notes">
<meta property="article:published_time" content="2022-01-22T19:10:04+01:00">
<meta property="article:modified_time" content="2022-01-22T19:10:04+01:00"><meta property="og:site_name" content="Nick Tehrany">
<meta property="article:published_time" content="2022-01-22 19:10:04 +0100 +0100">
</head>
<body>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ style=text-decoration:none>
<div class=logo>
<span class=logo__text>gst@nty: $ cd ~</span>
<span class=logo__cursor>
</span>
</div>
</a>
<span class=header__right>
<nav class=menu>
<ul class=menu__inner><li><a href=/publications>Publications</a></li><li><a href=/talks>Talks</a></li><li><a href=/awards>Awards</a></li><li><a href=/notes>Uni Notes</a></li><li><a href=/about>About</a></li>
</ul>
</nav>
<span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span>
<span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg>
</span>
</span>
</span>
</header>
<div class=content>
<main class=posts>
<div class=post-info>
<p>
</p>
</div>
<article>
<h1 class=post-title>
<a href=https://nicktehrany.github.io/notes/in4049tu-introduction-to-high-performance-computing/content/graph-partitioning/>Graph Partitioning</a>
</h1>
<div class=post-content>
<p>The goal with graph partitioning is that the entire graph is partitioned into even parts (about the same size/weight associated to the nodes/edged). However, choosing an optimal partitioning is NP-complete (can be proved that this is just as difficult as other hard problems in Nondeterministic Polynomial time). Therefore the only algorithms for partitioning have exponential cost on the number of nodes in the graph. This is why a heuristical approach is needed.</p>
<h2 id=partitioning-with-nodal-coordinates>Partitioning with Nodal Coordinates</h2>
<h3 id=inertial-partitioning>Inertial Partitioning</h3>
<p>A 2D graph, pick a line that has half the nodes on one side and the other on the other side (for other dimensions it&rsquo;s 2D plane, etc.). Then a perpendicular line to that line is chosen and each point is projected onto that lean, with which now the median to partition the nodes by minimizing the sum of the squares of each node to the line L. The resulting line is the total least squares of all the points.</p>
<h2 id=partitioning-without-nodal-coordinates>Partitioning without Nodal Coordinates</h2>
<h3 id=breadth-first-search-bfs>Breadth First Search (BFS)</h3>
<p>From a graph a subgraph $T$ with root $r$ is produced and each node is assigned a level which is its distance to the root. Then using a queue going up in the levels (visually from root going down but level id increases) and have a queue for processed nodes. For the current node, for all it&rsquo;s unmarked children (hasn&rsquo;t been processed) add the child to the new tree $T$ as node $N_T$. Also add the edge to the tree as $E_T$. Then add the this child to the queue for processing, mark that child as having been processed (this happens in for loop for all unmarked children, so first process all unmarked children then later their children). The queue is FIFO and the entire thing runs in a loop while the queue is not empty,</p>
<h3 id=coordinate-free-kernighanlin>Coordinate Free: Kernighan/Lin</h3>
<p>Given a graph, iteratively improve it by picking a new partition that splits the graph into two even halves $A$ and $B$, then find a subset of each of the splits $X$ from $A$ and $Y$ from $B$ such that they are even $|X|=|Y|$. If the cost of the two is lower when swapping the two swap them (cost is summation of edge weights)</p>
<h3 id=spectral-bisection>Spectral Bisection</h3>
<p>Using an Incidence matrix, we can show with it the graph connection by having in the Incidence matrix the connections depicted (1 for source -1 at the sink) vertex (each row in Incidence matrix is an edge and column is a vertex). Based on the Incidence matrix we can generate the Graph Laplacian as the transpose of the Incidence matrix time the Incidence matrix ($C^T * C$).</p>
<h2 id=multilevel-partitioning>Multilevel Partitioning</h2>
<p>Similar to the previous methods for multigrids, here also replace the graph by a coarse approximation and partition that approximated graph. That partition we can then iteratively improve. Coarsening a graph can be done with maximal matching, which is a greedy approach that checks each node and matches them such that there are no two edges that share an endpoint.</p>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}},window.addEventListener('load',a=>{document.querySelectorAll("mjx-container").forEach(function(a){a.parentElement.classList+='has-jax'})})</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
</div>
</article>
<hr>
<div class=post-info>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
500 Words
</p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2022-01-22
</p>
</div>
<div class=pagination>
<div class=pagination__title>
<span class=pagination__title-h>Read other posts</span>
<hr>
</div>
<div class=pagination__buttons>
<span class="button previous">
<a href=https://nicktehrany.github.io/notes/in4049tu-introduction-to-high-performance-computing/content/n-body/>
<span class=button__icon>←</span>
<span class=button__text>N-Body</span>
</a>
</span>
<span class="button next">
<a href=https://nicktehrany.github.io/notes/in4049tu-introduction-to-high-performance-computing/content/performance-analysis/>
<span class=button__text>Performance Analysis</span>
<span class=button__icon>→</span>
</a>
</span>
</div>
</div>
</main>
</div>
<footer class=footer>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css>
<div>
<div>
<a href=https://www.linkedin.com/in/nicktehrany/ target=_self><i class="fa fa-linkedin-square" style=font-size:36px></i></a>
<a href=https://github.com/nicktehrany target=_self><i class="fa fa-github" style=font-size:34px></i></a>
<a href=/misc/cv.pdf target=_self><i class="ai ai-cv ai-2x"></i></a>
</div>
<div>
<a href="https://scholar.google.com/citations?user=yWgr7XsAAAAJ&hl=en" target=_self><i class="ai ai-google-scholar ai-2x"></i></a>
<a href=https://www.semanticscholar.org/author/Tehrany/2105151990 target=_self><i class="ai ai-semantic-scholar ai-2x"></i></a>
</div>
</div>
<div class=footer__inner>
<div class=footer__content>
</div>
</div>
</footer>
</div>
<script type=text/javascript src=/bundle.min.e9f93b80e78a22e6f04cbb5f73e0f9c4ba60ff73a2a0ef85965c688f93dd1f2722a282e30e485603e4c65b1b346720e35f213435ec5556e196a97a68d097c80f.js integrity="sha512-6fk7gOeKIubwTLtfc+D5xLpg/3OioO+Fllxoj5PdHyciooLjDkhWA+TGWxs0ZyDjXyE0NexVVuGWqXpo0JfIDw=="></script>
</body>
</html>